{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"magicgui \ud83e\uddd9","text":"<p><code>magicgui</code> is a python library for building graphical user interfaces (GUIs).</p> <p>It aims to speed up data workflows by providing a simple, consistent API for creating GUIs to control various data types, that work across various environments.</p> <p>GUIs may be built manually using a variety of widgets, or generated automatically from python type hints.</p>"},{"location":"#magicgui-organization","title":"magicgui organization","text":"<p>magicgui can be thought of as performing two distinct tasks:</p> <ol> <li>Providing an simplified abstraction layer for GUI frameworks, allowing you to    use the same API to create UIs that can move between environments and    frameworks (such as a desktop app, or a Jupyter notebook).</li> <li>Providing a mapping of python types to widgets, allowing you to autogenerate    graphical user interfaces for functions and dataclasses by annotating with    standard python type hints.</li> </ol> <p>While there is some degree of customizeability, the emphasis is on rapid development of relatively simple GUIs, with minimal boilerplate.  For highly customized GUIs with complex layouts, it may be more appropriate to use a lower-level GUI framework.</p> <p>The API is organized into 2 main levels:</p> <p> </p> magicgui API layers"},{"location":"#python-type-mapping","title":"Python Type Mapping","text":"<p>At its highest level, magicgui provides a mapping of Python types to widgets. This API allows you to create graphical user interfaces for your functions and dataclasses simply by annotating them with standard python type hints.</p> Type hints?? <p>Type hints are a way to annotate your code with information about the types of variables and function arguments.  They are completely optional, but static type checkers and other libraries (like magicgui!) can use them to check your code and/or provide additional functionality.</p> <p>Typically, they are provided after a colon following a variable name or function argument.</p> <p>In the example below, <code>param_a</code> has been annotated as an <code>int</code>, <code>param_b</code> as a <code>str</code>, and the return value as a <code>list</code>.</p> <pre><code>def my_function(param_a: int, param_b: str) -&gt; list:\n    ...\n</code></pre> <p>If you are new to type annotations in Python, here are a few resources to get you started:</p> <ul> <li>PEP 484 - the Python Enhancement Proposal that introduced type hints to the language. (See also: PEP 483)</li> <li>Python docs - the official Python documentation on type hints and the <code>typing</code> module.</li> <li>The mypy documentation also has a lot of useful information, including this cheat sheet</li> </ul>"},{"location":"#create_widget","title":"<code>create_widget</code>","text":"<p><code>magicgui.widgets.create_widget</code> is a general function, used throughout the library, that allows you to create a widget for a specific Python type or value:</p> <p><pre><code>from magicgui.widgets import create_widget\n\n# passing a type to create_widget\nwidget = create_widget(annotation=int)\nwidget.show()\n</code></pre> </p> <p><pre><code># passing a value to create_widget\nwidget2 = create_widget(value=\"Hello World\")\nwidget2.show()\n</code></pre> </p> <p>For more details on how magicgui maps types to widgets, see Type Mapping.</p>"},{"location":"#magicgui_1","title":"magicgui","text":"<p>The <code>magicgui.magicgui</code> function is one way to autogenerate a compound Widget based on the parameters of a function:</p> <p><pre><code>from typing import Annotated, Literal\n# for Python &lt;= 3.8\n# from typing_extensions import Annotated\n# for Python &lt;= 3.7\n# from typing_extensions import Annotated, Literal\n\nfrom magicgui import magicgui\n\n\n@magicgui\ndef my_function(\n    param_a: int,\n    param_b: Annotated[int, {'widget_type': \"Slider\", 'max': 100}] = 42,\n    param_c: Literal[\"First\", \"Second\", \"Third\"] = \"Second\"\n):\n    print(\"param_a:\", param_a)\n    print(\"param_b:\", param_b)\n    print(\"param_c:\", param_c)\n\n# my_function now IS a widget, in addition to being a callable function\nmy_function.show()\n</code></pre> </p> <p>For more details on using <code>magicgui</code> and <code>magic_factory</code>, see the magicgui decorators page.</p>"},{"location":"#guiclass","title":"guiclass","text":"<p><code>magicgui.experimental.guiclass</code> is a newer experimental feature that provides an object-oriented alternative to <code>magicgui</code>.  It wraps <code>dataclasses.dataclass</code> and adds a <code>gui</code> attribute to the resulting class, which is a <code>magicgui</code>-generated widget that can be used to control the dataclass instance.  (The widget is only created when the <code>gui</code> attribute is accessed for the first time.)</p> <p><pre><code>from magicgui.experimental import guiclass, button\n\n@guiclass\nclass MyDataclass:\n    a: int = 0\n    b: str = 'hello'\n    c: bool = True\n\n    @button\n    def compute(self):\n        print(self.a, self.b, self.c)\n\nobj = MyDataclass(a=10, b='foo')\nobj.gui.show()\n</code></pre> </p> <p>For more details on using the <code>guiclass</code> decorator, see Dataclasses &amp; guiclass.</p>"},{"location":"#widgets","title":"Widgets","text":"<p>At the lower level, magicgui is a library of widgets (the individual elements that make up a graphical user interface). Each widget is customized to display and interact with a specific type of data.  In some cases, it makes more sense to create and arrange these widgets manually, rather than using the type-based autogeneration features described above.</p> <p>Magicgui acts as an abstraction layer for a variety of different GUI toolkits, allowing you to use the same API to create UIs that can move between environments (such as a desktop app, or a Jupyter notebook).</p> <p>Currently, magicgui supports the following backends:</p> <ul> <li>Qt (via   PySide2/PySide6   or   PyQt5/PyQt6)</li> <li>Jupyter Widgets (a.k.a.   \"IPyWidgets\")</li> </ul> <p>You can use <code>magicgui.widgets</code> to quickly build graphical user interfaces.</p> <p><pre><code>from magicgui import widgets\n\na = widgets.SpinBox(value=10, label=\"a\")\nb = widgets.Slider(value=20, min=0, max=100, label=\"b\")\nresult = widgets.LineEdit(value=a.value * b.value, label=\"result\")\nbutton = widgets.PushButton(text=\"multiply\")\n\n@button.clicked.connect\ndef on_button_click():\n    result.value = a.value * b.value\n\ncontainer = widgets.Container(widgets=[a, b, result, button])\ncontainer.show()\n</code></pre> </p> <p>To learn more about the available widgets and how to use them, see the Widgets Overview.</p> <p>...details</p> <p>Behind the scenes, magicgui declares a set of <code>WidgetProtocols</code> that each backend must implement, and every magicgui <code>Widget</code> is a wrapper around a backend-specific widget.  Most users will never need to worry about this, but it's good to know that it's there if you ever need to dig deeper.</p>"},{"location":"#events","title":"Events","text":"<p>All widgets (whether created directly or autogenerated based on type hints) emit events when their value changes or in response to interaction.</p> <p>To learn about connecting custom functionality to these events, see Events.</p>"},{"location":"#installation","title":"Installation","text":"<p>See installing magicgui.</p>"},{"location":"CONTRIBUTING/","title":"Contributing","text":"<p>Contributions are welcome!</p>"},{"location":"CONTRIBUTING/#development","title":"Development","text":"<p>To install <code>magicgui</code> for development, first clone the repository:</p> <pre><code>git clone https://github.com/pyapp-kit/magicgui\ncd magicgui\n</code></pre> <p>Then install the package in editable mode with the <code>dev</code> extra:</p> <pre><code>pip install -e .[dev]\n</code></pre> <p>To run the tests:</p> <pre><code>pytest\n</code></pre>"},{"location":"CONTRIBUTING/#code-quality","title":"Code Quality","text":"<p><code>magicgui</code> attempts to adhere to strict coding rules and employs the following static analysis tools to prevent errors from being introduced into the codebase:</p> <ul> <li>black - code formatting</li> <li>ruff - linting</li> <li>mypy - static type analysis</li> <li>codecov - test coverage</li> </ul> <p>To prevent continuous integration failures when contributing, please consider installing pre-commit in your environment to run all of these checks prior to checking in new code.</p> <pre><code>pre-commit install\n</code></pre> <p>To run the checks manually, you can use:</p> <pre><code>pre-commit run --all-files\n</code></pre>"},{"location":"CONTRIBUTING/#adding-a-widget","title":"Adding a widget","text":"<p>These instructions may change in the future as the repo structures changes. If they appear outdated as you follow them, please open an issue.</p> <p>To add a new widget, you will need to:</p> <ol> <li> <p>Create a new class in <code>magicgui/widgets/_concrete.py</code> that inherits from the    base class most appropriate for your widget (e.g. <code>ValueWidget</code>, or    <code>CategoricalWidget</code>).</p> <p>In some (complex) cases, you may need to extend one of the base classes. If so, it is likely that you will also need to extend one of the <code>Protocols</code> found in <code>magicgui.widgets.protocols</code>.  This is where all of protocols that backend classes need to implement to work with a given widget type. (Don't hesitate to open an issue if you're confused).</p> </li> <li> <p>Most likely, you will want to decorate the class with <code>@backend_widget</code>.    Using this decorator implies that there is a class with the same name in any    any backend modules that will support this widget type (e.g.    <code>magicgui.backends._qtpy.widgets</code> for Qt support.).</p> </li> <li>Make any changes necessary to your new concrete class. For example, you may    need to change the <code>value</code> property and corresponding setter to handle a    specific type.  This part of the code should be backend agnostic.</li> <li>Export the new class in <code>magicgui/widgets/__init__.py</code> so that it can be    imported from <code>magicgui.widgets</code>.</li> <li>Implement the backend widget class (using the same class name) in the    appropriate backend module (e.g. <code>magicgui.backends._qtpy.widgets</code> for Qt    support).  Usually this will mean implementing the appropriate    <code>_mgui_get/set_...</code> methods for the <code>Protocol</code> of the corresponding widget    base class your chose to extend.</li> <li>Export the backend widget class in the <code>__init__.py</code> of the backend module    (e.g. <code>magicgui.backends._qtpy.__init__.py</code> for Qt support).  This is    important, as that is where the <code>@backend_widget</code> decorator will look.</li> <li>Add a test for your new widget.</li> </ol> <p>For an example of a minimal PR adding a new widget, see #483, which added a <code>QuantityWidget</code> to be used with <code>pint.Quantity</code> objects.</p>"},{"location":"CONTRIBUTING/#associating-a-widget-with-a-type","title":"Associating a widget with a type","text":"<p>To associate your new widget with a specific type such that it will be used when someone annotates a parameter with that type, you will need to update code in <code>magicgui.type_map._type_map</code>.</p> <p>In the simplest of cases, this will mean adding a new entry to the <code>magicgui.type_map._type_map._SIMPLE_TYPES</code> dict.  This is a mapping from a python type to a widget class.  (Note that all subclasses of the type will also be matched.)</p> <p>For more complex cases, you can add a new conditional to the body of the <code>match_type</code> function.  That function should always return a tuple of widget type, and kwargs that will be passed to the widget constructor. For example: <code>return widgets.MyNewWidget, {}</code>.</p>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation locally, you will need to install the <code>docs</code> extra:</p> <pre><code>pip install -e .[docs]\n</code></pre> <p>Then, from the root of the repository, run:</p> <pre><code>mkdocs serve\n</code></pre> <p>This will start a local server at <code>http://127.0.0.1:8000/</code> where you can view the documentation as you edit it.</p>"},{"location":"dataclasses/","title":"Dataclasses &amp; guiclass","text":""},{"location":"dataclasses/#what-are-dataclasses","title":"What are dataclasses?","text":"<p><code>dataclasses</code> are a feature added in Python 3.7 (PEP 557) that allow you to simply define classes that store a specific set of data.  They encourage clear, type-annotated code, and are a great way to define data structures with minimal boilerplate.</p> <p>New to dataclasses?</p> <p>If you're totally new to dataclasses, you might want to start with the official documentation for the <code>dataclasses</code> module, or this Real Python post on dataclasses. The following is a very brief example of the key features:</p> Example dataclass<pre><code>from dataclasses import dataclass\n\n@dataclass  # (1)!\nclass Person:\n    name: str # (2)!\n    age: int = 0  # (3)!\n\np = Person(name='John', age=30)  # (4)!\nprint(p) # (5)!\n</code></pre> <ol> <li>The <code>@dataclass</code> decorator is used to mark a class as a dataclass.  This     will automatically generate an <code>__init__</code> method with a parameter for     each annotated class attribute.</li> <li>Attribute names are annotated with types.  Note that, as with all Python     type hints, these have no runtime effect (i.e. no validation is performed).</li> <li>Optional attributes can be defined with a default value. If no default value     is specified, then the field is required when creating a new object.</li> <li>Creating a new object is as simple as passing in the required arguments.</li> <li>The <code>__repr__</code> method is automatically generated and will print out the     class name and all of the attributes and their current values.</li> </ol>"},{"location":"dataclasses/#dataclass-patterns-outside-the-standard-library","title":"dataclass patterns outside the standard library","text":"<p>The <code>dataclasses</code> module is not the only way to define data-focused classes in Python. There are other libraries that provide similar functionality, and some of them have additional features that are not available in the standard library.</p> <ul> <li><code>attrs</code> is a popular library that   provides a number of additional features on top of the standard library   <code>dataclasses</code>, including complex validation and type conversions.</li> <li><code>pydantic</code> is a library that provides   runtime type enforcement and casting, serialization, and other features.</li> <li><code>msgspec</code> is a fast serialization library   with a <code>msgspec.Struct</code> that is similar to a dataclass.</li> </ul>"},{"location":"dataclasses/#magicgui-guiclass","title":"magicgui <code>guiclass</code>","text":"<p>Experimental</p> <p>This is an experimental feature.  The API may change in the future without deprecations or warnings.</p> <p>magicgui supports the dataclass API as a way to define the interface for compound widget, where each attribute of the dataclass is a separate widget.  The <code>magicgui.experimental.guiclass</code> decorator can be used to mark a class as a \"GUI class\".  A GUI class is a Python standard <code>dataclass</code> that has two additional features:</p> <ol> <li>A property (named \"<code>gui</code>\" by default) that returns a <code>Container</code>    widget which contains a widget for each attribute of the dataclass.</li> <li>An property (named \"<code>events</code>\" by default) that returns a    <code>psygnal.SignalGroup</code> object that allows you to connect callbacks    to the change event of any of field in the dataclass.  (Under the hood,    this uses the    <code>@evented</code> dataclass decorator from <code>psygnal</code>.)</li> </ol> <p>Tip</p> <p>You can still use all of the standard dataclass features, including <code>field</code> values, <code>__post_init__</code> processing, and <code>ClassVar</code>.</p> <p>Info</p> <p>In the future, we may also support other dataclass-like objects, such as <code>pydantic</code> models, <code>attrs</code> classes, and <code>traitlets</code> classes.</p> <p><pre><code>from magicgui.experimental import guiclass\n\n@guiclass\nclass MyDataclass:\n    a: int = 0\n    b: str = 'hello'\n    c: bool = True\n\nobj = MyDataclass()\nobj.gui.show()\n</code></pre> </p> <p>The individual widgets in the <code>Container</code> may be accessed by the same name as the corresponding attribute. For example, <code>obj.gui.a</code> will return the <code>SpinBox</code> widget that controls the value of the <code>a</code> attribute.</p>"},{"location":"dataclasses/#two-way-data-binding","title":"Two-way data binding","text":"<p>As you interact programmatically with the <code>obj</code> instance, the widgets in the <code>obj.gui</code> will update.  Similarly, as you change the value of the widgets in the <code>obj.gui</code>, the values of the <code>obj</code> instance will be updated.</p> <p><pre><code>obj = MyDataclass(a=10)\nobj.b = 'world'\nobj.c = False\n\nobj.gui.show()\n</code></pre> </p> <p>All magicgui-related stuff is in the <code>gui</code> attribute</p> <p>The original dataclass instance (<code>obj</code>) is essentially untouched.  Just as in a regular dataclass, <code>obj.a</code> returns the current value of <code>a</code> in the dataclass.  The widget for the class will be at <code>obj.gui</code> (or whatever name you specified in the <code>gui_name</code> parameter) So, <code>obj.gui.a.value</code>, returns the current value of the widget.  Unless you explicitly disconnect the gui from the underlying object/model, the two will always be in sync.</p>"},{"location":"dataclasses/#adding-buttons-and-callbacks","title":"Adding buttons and callbacks","text":"<p>Buttons are one of the few widget types that tend not to have an associated value, but simply trigger a callback when clicked.  That is: it doesn't often make sense to add a field to a dataclass representing a button. To add a button to a <code>guiclass</code>, decorate a method with the <code>magicgui.experimental.button</code> decorator.</p> <p>positioning buttons</p> <p>Currently, all buttons are appended to the end of the widget. The ability to position the button in the layout will be added in the future.</p> <p>Any additional keyword arguments to the <code>button</code> decorator will be passed to the <code>magicgui.widgets.PushButton</code> constructor (e.g. <code>label</code>, <code>tooltip</code>, etc.)</p> <p><pre><code>from magicgui.experimental import guiclass, button\n\n@guiclass\nclass Greeter:\n    first_name: str\n\n    @button\n    def say_hello(self):\n        print(f'Hello {self.first_name}')\n\ngreeter = Greeter('Talley')\ngreeter.gui.show()\n</code></pre> </p> <p> clicking the \"say_hello\" button will print \"Hello Talley\" to the console</p> <p>Tip</p> <p>As your widget begins to manage more internal state, the <code>guiclass</code> pattern becomes much more useful than the <code>magicgui</code> decorator pattern -- which was designed with pure functions that take inputs and return outputs in mind.</p>"},{"location":"decorators/","title":"magicgui &amp; magic_factory","text":""},{"location":"decorators/#from-object-to-gui","title":"From Object to GUI","text":"<p>The eponymous feature of <code>magicgui</code> is the <code>magicgui.magicgui</code> function, which converts an object into a widget.</p> <p>Info</p> <p>Currently, the only supported objects are functions, but in the future <code>magicgui.magicgui</code> may accept other objects, such as dataclass instances</p> <p>When used to decorate a function, <code>@magicgui</code> will autogenerate a graphical user interface (GUI) by inspecting the function signature and adding an appropriate GUI widget for each parameter, as described in Type Hints to Widgets. Parameter <code>types</code> are taken from type hints, if provided, or inferred using the type of the default value otherwise.</p> <p><pre><code>import math\nfrom enum import Enum\nfrom magicgui import magicgui\n\n# dropdown boxes are best made by creating an enum\nclass Medium(Enum):\n    Glass = 1.520\n    Oil = 1.515\n    Water = 1.333\n    Air = 1.0003\n\n# decorate your function with the @magicgui decorator\n@magicgui(call_button=\"calculate\")\ndef snells_law(aoi=30.0, n1=Medium.Glass, n2=Medium.Water, degrees=True):\n    aoi = math.radians(aoi) if degrees else aoi\n    try:\n        result = math.asin(n1.value * math.sin(aoi) / n2.value)\n        return math.degrees(result) if degrees else result\n    except ValueError:\n        # beyond the critical angle\n        return \"Total internal reflection!\"\n\nsnells_law.show()\n</code></pre> </p> <p>The object returned by the <code>magicgui</code> decorator is an instance of <code>magicgui.widgets.FunctionGui</code>.  It can still be called like the original function, but it also knows how to present itself as a GUI.</p>"},{"location":"decorators/#two-way-data-binding","title":"Two-Way Data Binding","text":"<p>The modified <code>snells_law</code> object gains attributes named after each of the parameters in the function.  Each attribute is an instance of a <code>magicgui.widgets.Widget</code> subclass (suitable for the data type represented by that parameter). As you make changes in your GUI, the attributes of the <code>snells_law</code> object will be kept in sync.  For instance, change the first dropdown menu from \"Glass\" to \"Oil\", and the corresponding <code>n1</code> object on <code>snells_law</code> will change its value to <code>1.515</code>:</p> <pre><code>snells_law.n1.value  # 1.515\n</code></pre> <p>It goes both ways: set a parameter in the console and it will change in the GUI:</p> <p><pre><code>snells_law.aoi.value = 47\nsnells_law.show()\n</code></pre> </p>"},{"location":"decorators/#its-still-a-function","title":"It's still a function","text":"<p><code>magicgui</code> tries very hard to make it so that the decorated object behaves as much like the original object as possible.</p> <p>We can invoke the function in a few ways:</p> <ul> <li> <p>Because we provided the <code>call_button</code> argument to the   <code>magicgui</code> decorator, a new button was created that will   execute the function with the current gui parameters when clicked.</p> </li> <li> <p>We can call the object just like the original function.</p> <pre><code>snells_law()        # 34.7602\nsnells_law(aoi=12)  # 13.7142\n</code></pre> <p>Now however, the current values from the GUI will be used as the default values for any arguments that are not explicitly provided to the function.</p> <pre><code>snells_law.aoi.value = 12\nsnells_law()  # 13.7142\nsnells_law(aoi=30)  # 34.7602\n</code></pre> <p>In essence, your original function now has a \"living\" signature whose defaults change as the user interacts with your GUI.</p> <pre><code>import inspect\n\ninspect.signature(snells_law)\n# &lt;MagicSignature(\n#   aoi=12.0, n1=&lt;Medium.Glass: 1.52&gt;, n2=&lt;Medium.Water: 1.333&gt;, degrees=True\n# )&gt;\n# notice how the default `aoi` is now 12 ... because we changed it above\n</code></pre> </li> <li> <p>You can still override positional or keyword arguments in the original   function, just as you would with a regular function.</p> <p>Note</p> <p>calling the function with values that differ from the GUI will not set the values in the GUI... It's just a one-time call.</p> <pre><code># in radians, overriding the value for the second medium (n2)\nsnells_law(0.8, n2=Medium.Air, degrees=False)  # 'Total internal reflection!'\n</code></pre> </li> </ul>"},{"location":"decorators/#connecting-events","title":"Connecting Events","text":""},{"location":"decorators/#function-calls","title":"Function Calls","text":"<p>With a GUI, you are usually looking for something to happen as a result of calling the function.  The function will have a new <code>called</code> attribute that you can <code>connect</code> to an arbitrary callback function:</p> <pre><code>@snells_law.called.connect\ndef my_callback(value: str):\n    # The callback receives an `Event` object that has the result\n    # of the function call in the `value` attribute\n    print(f\"Your function was called! The result is: {value}\")\n\nresult = snells_law()\n</code></pre> <p>Now when you call <code>snells_law()</code>, or click the <code>calculate</code> button in the gui, <code>my_callback</code> will be called with the result of the calculation.</p>"},{"location":"decorators/#parameter-changes","title":"Parameter Changes","text":"<p>You can also listen for changes on individual function parameters by connecting to the <code>&lt;parameter_name&gt;.changed</code> signal:</p> <pre><code># whenever the current value for n1 changes, print it to the console:\n@snells_law.n1.changed.connect\ndef _on_n1_changed(x: Medium):\n    print(f\"n1 was changed to {x}\")\n\nsnells_law.n1.value = Medium.Air\n</code></pre> <p>Note</p> <p>This signal will be emitted regardless of whether the parameter was changed in the GUI or via by directly setting the paramaeter on the gui instance.</p>"},{"location":"decorators/#usage-as-a-decorator-is-optional","title":"Usage As a Decorator is Optional","text":"<p>Remember: the <code>@decorator</code> syntax is just syntactic sugar.  You don't have to use <code>@magicgui</code> to decorate your function declaration. You can also just call it with your function as an argument:</p> <p>This decorator usage:</p> <pre><code>@magicgui(auto_call=True)\ndef function():\n    pass\n</code></pre> <p>is equivalent to this:</p> <pre><code>def function():\n    pass\n\nfunction = magicgui(function, auto_call=True)\n</code></pre> <p>In many cases, it will actually be desirable not to use magicgui as a decorator if you don't need a widget immediately, but want to create one later (see also the <code>magic_factory</code> decorator.)</p> <pre><code># some time later...\nwidget_instance = magicgui(function)\n</code></pre>"},{"location":"decorators/#magic_factory","title":"magic_factory","text":"<p>The <code>magicgui.magic_factory</code> function/decorator acts very much like the <code>magicgui</code> decorator, with one important difference:</p> <p>Unlike <code>magicgui</code>, <code>magic_factory</code> does not return a widget instance immediately.  Instead, it returns a \"factory function\" that can be called to create a widget instance.</p> <p>This is an important distinction to understand.  In most cases, the <code>@magicgui</code> decorator is useful for interactive use or rapid prototyping.  But if you are writing a library or package where someone else will be instantiating your widget (a napari plugin is a good example), you will likely want to use <code>magic_factory</code> instead, (or create your own Widget Container subclass).</p> <p>it's just a partial</p> <p>If you're familiar with <code>functools.partial</code>, you can think of <code>magic_factory</code> as a partial function application of the <code>magicgui</code> decorator (in fact, <code>magic_factory</code> is a subclass of <code>partial</code>). It is very roughly equivalent to:</p> <pre><code>def magic_factory(func, *args, **kwargs):\n    return partial(magicgui, func, *args, **kwargs)\n</code></pre>"},{"location":"decorators/#widget_init","title":"<code>widget_init</code>","text":"<p><code>magic_factory</code> gains one additional parameter: <code>widget_init</code>.  This accepts a callable that will be called with the new widget instance each time the factory is called.  This is a convenient place to add additional initialization or connect events.</p> <pre><code>from magicgui import magic_factory\n\ndef _on_init(widget):\n    print(\"widget created!\", widget)\n    widget.y.changed.connect(lambda x: print(\"y changed!\", x))\n\n@magic_factory(widget_init=_on_init)\ndef my_factory(x: int, y: str): ...\n\nnew_widget = my_factory()\n</code></pre>"},{"location":"decorators/#the-lack-of-magic-in-magicgui","title":"The (lack of) \"magic\" in magicgui","text":"<p>Just to demystify the name a bit, there really isn't a whole lot of \"magic\" in the <code>magicgui</code> decorator.  It's really just a thin wrapper around the <code>magicgui.widgets.create_widget</code> function, to create a <code>Container</code> with a sub-widget for each parameter in the function signature.</p> <p>The widget creation is very roughly equivalent to something like this:</p> <p><pre><code>from inspect import signature, Parameter\nfrom magicgui.widgets import create_widget, Container\nfrom magicgui.types import Undefined\n\n\ndef pseudo_magicgui(func: 'Callable'):\n    return Container(\n        widgets=[\n            create_widget(p.default, annotation=p.annotation, name=p.name)\n            for p in signature(func).parameters.values()\n        ]\n    )\n\ndef some_func(x: int = 2, y: str = 'hello'):\n    return x, y\n\nmy_widget = pseudo_magicgui(some_func)\nmy_widget.show()\n</code></pre> </p> <p>In the case of <code>magicgui</code>, a special subclass of <code>Container</code> (<code>FunctionGui</code>) is used, which additionally adds a <code>__call__</code> method that allows the widget to behave like the original function.</p>"},{"location":"events/","title":"Events","text":"<p>All magicgui widgets emit events when certain properties change.  For each event there is a corresponding signal attribute on the widget that can be connected to a callback function. For example, a <code>PushButton</code> emits an event when it is clicked, and all <code>ValueWidget</code> subclasses (like <code>Slider</code> or <code>LineEdit</code>) emit an event when their value changes.</p>"},{"location":"events/#connecting-to-events","title":"Connecting to events","text":"<p>To connect a callback to an event, use the <code>connect</code> method of the signal attribute.  The exact signals available on each widget are mostly defined in the base classes, and are listed on the API page for each respective widget.</p> <p>For example, to connect a callback to a <code>LineEdit</code> widget's <code>changed</code> event:</p> Widget API<code>magicgui</code> decorator<code>magic_factory</code> decorator <pre><code>from magicgui import widgets\n\ntext = widgets.LineEdit(value='type something')\ntext.changed.connect(lambda val: print(f\"Text changed to: {val}\"))\n</code></pre> <pre><code>from magicgui import magicgui\n\n@magicgui\ndef my_function(text: str):\n    ...\n\nmy_function.text.changed.connect(lambda val: print(f\"Text changed to: {val}\"))\n</code></pre> <pre><code>from magicgui import magic_factory\n\ndef _on_init(widget):\n    widget.text.changed.connect(lambda val: print(f\"Text changed to: {val}\"))\n\n@magic_factory(widget_init=_on_init)\ndef my_function(text: str):\n    ...\n\nmy_widget = my_function()\n</code></pre> <p>It's all <code>psygnal</code> under the hood</p> <p>magicgui uses psygnal for its event system.  For greater detail on the <code>connect</code> method and its options, see the Usage section of psygnal's documentation, or the <code>psygnal.SignalInstance.connect</code> API reference.</p> <p>Tip</p> <p>Note that <code>connect</code> returns the callable that it was passed, so you can use it as a decorator if you prefer.</p> <pre><code>text = widgets.LineEdit(value='type something')\n\n# this works\ntext.changed.connect(lambda val: print(f\"Text changed to: {val}\"))\n\n# so does this\n@text.changed.connect\ndef on_text_changed(val):\n    print(f\"Text changed to: {val}\")\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<p>magicgui is a pure Python package, and can be installed with <code>pip</code>:</p> <pre><code>pip install magicgui\n</code></pre> <p>or with <code>conda</code>:</p> <pre><code>conda install -c conda-forge magicgui\n</code></pre>"},{"location":"installation/#backends","title":"Backends","text":"<p>magicgui requires a backend to be installed in order to function, but it does not specify a particular backend by default.  The following backends are available:</p> <ul> <li><code>PyQt5</code>:  <code>pip install magicgui[pyqt5]</code></li> <li><code>PyQt6</code>:  <code>pip install magicgui[pyqt6]</code></li> <li><code>PySide2</code>:  <code>pip install magicgui[pyside2]</code></li> <li><code>PySide6</code>:  <code>pip install magicgui[pyside6]</code></li> <li><code>Jupyter Widgets</code>:  <code>pip install magicgui[jupyter]</code></li> </ul> <p>Important</p> <p>Note not all widgets are necessarily implemented for all backends. Most widgets in the widget docs specify which backends are supported.</p>"},{"location":"installation/#extras","title":"Extras","text":"<p>The <code>Image</code> widget requires <code>pillow</code>. You may use the <code>image</code> extra:</p> <pre><code>pip install magicgui[image]\n</code></pre> <p>The <code>magicgui.tqdm</code> module requires <code>tqdm</code>. You may use the <code>tqdm</code> extra:</p> <pre><code>pip install magicgui[tqdm]\n</code></pre> <p>The <code>QuantityEdit</code> widget requires <code>pint</code>. You may use the <code>quantity</code> extra:</p> <pre><code>pip install magicgui[quantity]\n</code></pre>"},{"location":"type_map/","title":"Type Hints to Widgets","text":"<p>One of the key offerings of magicgui is the ability to automatically generate Widgets from Python type hints.  This page describes how type hints are mapped to Widgets, and how to customize that mapping.</p>"},{"location":"type_map/#default-type-mapping","title":"Default Type Mapping","text":"<p>By default, The following python <code>Type Hint</code> annotations are mapped to the corresponding <code>Widget</code> class, and parametrized with the corresponding <code>kwargs</code> (when applicable):</p> Type Hint Widget <code>__init__</code> kwargs <code>bool</code> <code>Slider</code> <code>int</code> <code>Slider</code> <code>float</code> <code>FloatSlider</code> <code>str</code> <code>LineEdit</code> <code>range</code> <code>RangeEdit</code> <code>slice</code> <code>SliceEdit</code> <code>list</code> <code>ListEdit</code> <code>tuple</code> <code>TupleEdit</code> <code>pathlib.Path</code> <code>FileEdit</code> <code>os.PathLike</code> <code>FileEdit</code> <code>Sequence[pathlib.Path]</code> <code>FileEdit</code> <code>{'mode': 'rm'}</code> <code>datetime.time</code> <code>TimeEdit</code> <code>datetime.timedelta</code> <code>TimeEdit</code> <code>datetime.date</code> <code>DateEdit</code> <code>datetime.datetime</code> <code>DateTimeEdit</code> <code>Literal['a', 'b']</code> <code>ComboBox</code> <code>{'choices': ['a', 'b']}</code> <code>Set[Literal['a', 'b']]</code> <code>Select</code> <code>{'choices': ('a', 'b')}</code> <code>enum.Enum</code> <code>ComboBox</code> <code>{'choices': &lt;enum 'Enum'&gt;}</code> <code>magicgui.widgets.ProgressBar</code> <code>ProgressBar</code> <code>{'bind': &lt;function match_type.&lt;locals&gt;.&lt;lambda&gt; at 0x1436d36a0&gt;, 'visible': True}</code> <code>types.FunctionType</code> <code>FunctionGui</code> <code>{'function': ...}</code> <code>pint.Quantity</code> <code>QuantityEdit</code>"},{"location":"type_map/#example","title":"Example","text":"<p><pre><code>from magicgui import widgets\nimport pathlib\nimport os\nimport datetime\nfrom typing import Literal, Set, Sequence\nimport types\nimport pint\nimport enum\n\ntypes = [\n    bool, int, float, str, range, slice, list,\n    pathlib.Path, os.PathLike, Sequence[pathlib.Path],\n    datetime.time, datetime.timedelta, datetime.date, datetime.datetime,\n    Literal['a', 'b'], Set[Literal['a', 'b']], enum.Enum,\n    widgets.ProgressBar, pint.Quantity,\n]\n\nwdg = widgets.Container(\n    widgets=[\n        widgets.create_widget(annotation=t, label=str(t)) for t in types\n    ]\n)\nwdg.show()\n</code></pre> </p>"},{"location":"type_map/#customizing-widget-options-with-typingannotated","title":"Customizing Widget Options with <code>typing.Annotated</code>","text":"<p>Widget options and types may be embedded in the type hint itself using <code>typing.Annotated</code>.</p> <p>Note</p> <p>This is not the only way to customize the widget type or options in magicgui.  Some functions (like <code>magicgui.magicgui</code>) also accept <code>**param_options</code> keyword arguments that map parameter names to dictionaries of widget options.</p>"},{"location":"type_map/#overriding-the-default-type","title":"Overriding the Default Type","text":"<p>To override the widget class used for a given object type, use the <code>widget_type</code> key in the <code>Annotated</code> <code>kwargs</code>.  It can be either the string name of one of the built-in widgets, or any <code>Widget</code> subclass object.</p> Type Hint Widget <code>__init__</code> kwargs <code>Annotated[int, {'widget_type': 'Slider'}]</code> <code>Slider</code> <code>Annotated[float, {'widget_type': 'FloatSlider'}]</code> <code>FloatSlider</code>"},{"location":"type_map/#overriding-the-default-options","title":"Overriding the Default Options","text":"<p>Any additional kwargs will be passed to the widget constructor (and must be valid for the corresponding widget type).</p> Type Hint Widget <code>__init__</code> kwargs <code>Annotated[int, {'step': 10, 'max': 50}]</code> <code>Slider</code> <code>{'step': 10, 'max': 50}</code> <code>Annotated[int, {'choices': [1, 2, 3]}]</code> <code>Slider</code> <code>{'choices': [1, 2, 3]}</code>"},{"location":"type_map/#examples","title":"Examples","text":"<p>Create a widget using standard type map:</p> create_widgetmagicgui decoratorguiclass decorator <pre><code>my_widget = widgets.create_widget(value=42, annotation=int)\n</code></pre> <pre><code>from magicgui import magicgui\n\n@magicgui\ndef my_widget(x: int = 42):\n    return x\n</code></pre> <pre><code>from magicgui.experimental import guiclass\n\n@guiclass\nclass MyObject:\n    x: int = 42\n\nobj = MyObject()\nmy_widget = obj.gui\n</code></pre> <p>Customize a widget using <code>typing.Annotated</code>:</p> create_widgetmagicgui decoratorguiclass decorator <pre><code>from typing import Annotated\n\nInt10_50 = Annotated[int, (('widget_type', 'Slider'),('step', 10),('max', 50))]\nwdg2 = widgets.create_widget(value=42, annotation=Int10_50)\n</code></pre> <pre><code>from magicgui import magicgui\nfrom typing import Annotated\n\nInt10_50 = Annotated[int, (('widget_type', 'Slider'),('step', 10),('max', 50))]\n\n@magicgui\ndef my_widget(x: Int10_50 = 42):\n    ...\n</code></pre> <pre><code>from magicgui.experimental import guiclass\nfrom typing import Annotated\n\nInt10_50 = Annotated[int, (('widget_type', 'Slider'),('step', 10),('max', 50))]\n\n@guiclass\nclass MyObject:\n    x: Int10_50 = 42\n\nobj = MyObject()\nmy_widget = obj.gui\n</code></pre> <p>Note that you may also customize widget creation with kwargs to <code>create_widget</code></p> <p><pre><code>from typing import Annotated\nfrom magicgui.widgets import Slider\n\noptions = {'step': 10, 'max': 50}\nwdg3 = widgets.create_widget(value=42, widget_type=Slider, options=options)\nwdg3.show()\n</code></pre> </p> <p>... or to the <code>magicgui</code> decorator:</p> <p><pre><code>@magicgui(x={'widget_type': 'Slider', 'step': 10, 'max': 50})\ndef my_widget(x: int = 42):\n    ...\n\nmy_widget.show()\n</code></pre> </p>"},{"location":"type_map/#return-type-mapping","title":"Return Type Mapping","text":"<p>In some cases, magicgui may be able to create a widget for the return annotation of a function.</p> <p>... more to come ...</p>"},{"location":"type_map/#postponed-annotations","title":"Postponed annotations","text":"<p>Using forward references and <code>__future__.annotations</code> with magicgui is possible, but requires some extra care.  Read on for more details.</p>"},{"location":"type_map/#forward-references","title":"Forward References","text":"<p>When a type hint contains names that have not been defined yet, that definition may be expressed as a string literal, to be resolved later.  This is called a <code>Forward Reference</code> (see PEP 484).  This is useful when you want to use a type hint that refers to a type that has not yet been defined, or when you want to avoid importing a type that is only used in a type hint.</p> <pre><code>from typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from mymodule import MyType\n\ndef my_function(x: 'MyType') -&gt; None:\n    ...\n</code></pre>"},{"location":"type_map/#__future__annotations","title":"<code>__future__.annotations</code>","text":"<p>In Python 3.7, the <code>__future__.annotations</code> feature was introduced (PEP 563), which postpones the evaluation of type annotations.  The effect of this is that no type annotations will be evaluated at definition time, and all type annotations will be treated as strings (regardless of whether they are enclosed in quotes or not).</p> <pre><code>from __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from mymodule import MyType\n\n# no longer necessary to use quotes around 'MyType'\ndef my_function(x: MyType) -&gt; None:\n    ...\n</code></pre> <p>While this is a useful feature for developers, it does make it significantly more difficult to use those type annotations at runtime.</p> <p>Magicgui does attempt to resolve forward references it encounters (see Resolving type hints at runtime for gory details), but this is an imperfect process, and may not always work.</p>"},{"location":"type_map/#if-you-must-use-postponed-annotations","title":"If You Must Use Postponed Annotations","text":"<p>As a general rule, if you must use forward references or <code>__future__.annotations</code> in a module that uses magicgui, you should:</p> <ul> <li>don't use typing syntax that is not valid for ALL python versions   you wish to support (e.g. <code>str | int</code> instead of <code>Union[str, int]</code>   in python &lt; 3.10), as these will raise an exception when magicgui   attempts to evaluate them at runtime.</li> <li> <p>use fully qualified names for all type hints, as these will be   easier for magicgui to resolve without user-supplied namespaces.</p> <pre><code>from __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    import mymodule\n\n# this is easier for magicgui to resolve\ndef my_function(x: mymodule.MyType) -&gt; None:\n    ...\n</code></pre> </li> </ul>"},{"location":"type_map/#registering-support-for-custom-types","title":"Registering Support for Custom Types","text":"<p>Any third-party library may use the <code>magicgui.register_type</code> function to register its types with magicgui.  When a registered type is used as an annotation, the registered widget will be used.</p>"},{"location":"type_map/#known-third-party-support-for-magicgui","title":"Known Third-Party Support for magicgui","text":"<p>Hi developer! </p> <p>Have a library that registers types with magicgui?  Let us know and we'll add it to this list!</p>"},{"location":"type_map/#napari","title":"napari","text":"<p>napari has registered a number of its types to provide access to napari-specific objects using type annotations in magicgui. Details may be found in napari's documentation on using <code>magicgui</code> in napari.</p>"},{"location":"widgets/","title":"Widgets","text":"<p>Tip</p> <p>If you're looking for an index of all available widgets, see the Widget Index.</p> <p>All individual graphical elements in magicgui are \"widgets\", and all widgets are instances of <code>magicgui.widgets.Widget</code>.  Widgets may be created directly:</p> <p><pre><code>from magicgui.widgets import LineEdit\n\nline_edit = LineEdit(value='hello!')\nline_edit.show()\n</code></pre> </p> <p>Some widgets (such as <code>magicgui.widgets.Container</code>) are composite widgets that comprise other widgets:</p> <p><pre><code>from magicgui.widgets import LineEdit, SpinBox, Container\n\nline_edit = LineEdit(value='hello!')\nspin_box = SpinBox(value=400)\ncontainer = Container(widgets=[line_edit, spin_box])\ncontainer.show()\n</code></pre> </p> <p>magicgui provides a way to automatically select a widget given a python value or type annotation using <code>magicgui.widgets.create_widget</code>. Here is an example that yields the same result as the one above:</p> <p><pre><code>from magicgui.widgets import create_widget\n\nx = 'hello!'\ny = 400\ncontainer = Container(widgets=[create_widget(i) for i in (x, y)])\ncontainer.show()\n</code></pre> </p> <p>Tip</p> <p>Because there are often multiple valid widget types for a given python object, you may sometimes wish to create widgets directly, or use the <code>widget_type</code> argument in <code>create_widget()</code></p>"},{"location":"widgets/#the-widget-hierarchy","title":"The widget hierarchy","text":"<pre><code>graph TB\n    A([Widget])--&gt;B([ValueWidget])\n    A--&gt;C([ContainerWidget])\n    B--&gt;D([RangedWidget])\n    B--&gt;E([ButtonWidget])\n    B--&gt;F([CategoricalWidget])\n    C--&gt;H([MainWindowWidget])\n    C--&gt;G([FunctionGui])\n    D--&gt;I([SliderWidget])\n    click A \"#widget\"\n    click B \"#valuewidget\"\n    click C \"#containerwidget\"\n    click D \"#rangedwidget\"\n    click E \"#buttonwidget\"\n    click F \"#categoricalwidget\"\n    click H \"#mainwindowwidget\"\n    click G \"#functiongui\"\n    click I \"#sliderwidget\"</code></pre> <p>Many widgets present similar types of information in different ways.  magicgui tries to maintain a consistent API among all types of widgets that are designed to represent similar objects.  The general class of widget you are working with will determine the properties and attributes it has.</p> <p>Note</p> <p>The categories shown below are sorted by their base class (such as <code>ValueWidget</code> and <code>RangedWidget</code>). The bases are not intended to be instantiated directly.  Instead, you would create the widget type you wanted, such as <code>LineEdit</code> or <code>SpinBox</code>, respectively.</p>"},{"location":"widgets/#widget","title":"<code>Widget</code>","text":"<p>As mentioned above, all magicgui widgets derive from <code>magicgui.widgets.Widget</code> and have the following attributes (this list is not comprehensive, see the <code>magicgui.widgets.Widget</code> API):</p> Attribute Type Description <code>name</code> <code>str</code> The name or \"ID\" of this widget (such as a function parameter name to which this widget corresponds). <code>annotation</code> <code>Any</code> A type annotation for the value represented by the widget. <code>label</code> <code>str</code> A string to use for an associated Label widget (if this widget is being shown in a <code>magicgui.widgets.Container</code> widget, and <code>container.labels</code> is <code>True</code>). By default, <code>name</code> will be used. Note: <code>name</code> refers the name of the parameter, as might be used in a signature, whereas label is just the label for that widget in the GUI. <code>tooltip</code> <code>str</code> A tooltip to display when hovering over the widget. <code>visible</code> <code>bool</code> Whether the widget is visible."},{"location":"widgets/#valuewidget","title":"<code>ValueWidget</code>","text":"<p>In addition to the base <code>Widget</code> properties mentioned above, the following <code>ValueWidgets</code> track some <code>value</code>:</p> Widget Description <code>Label</code> A non-editable text display. <code>LineEdit</code> A one-line text editor. <code>LiteralEvalLineEdit</code> A one-line text editor that evaluates strings as python literals. <code>Password</code> A one-line text editor that obscures input. <code>TextEdit</code> A widget to edit and display both plain and rich text. <code>FileEdit</code> A LineEdit widget with a button that opens a FileDialog. <code>RangeEdit</code> A widget to represent a python range object, with start/stop/step. <code>SliceEdit</code> A widget to represent <code>slice</code> objects, with start/stop/step. <code>DateTimeEdit</code> A widget for editing dates and times. <code>DateEdit</code> A widget for editing dates. <code>TimeEdit</code> A widget for editing times. <code>Table</code> A widget to represent columnar or 2D data with headers. <code>QuantityEdit</code> A combined <code>LineEdit</code> and <code>ComboBox</code> to edit a <code>pint.Quantity</code>. Attribute Type Description <code>value</code> <code>Any</code> The current value of the widget. <code>changed</code> <code>psygnal.SignalInstance</code> A <code>psygnal.SignalInstance</code> that will emit an event when the <code>value</code> has changed.  Connect callbacks to the change event using <code>widget.changed.connect(callback)</code> <code>bind</code> <code>Any, optional</code> A value or callback to bind this widget.  If bound, whenever <code>widget.value</code> is accessed, the value provided here will be returned.  The bound value can be a callable, in which case <code>bound_value(self)</code> will be returned (i.e. your callback must accept a single parameter, which is this widget instance.). see <code>ValueWidget.bind</code> for details. <p>Here is a demonstration of all these:</p> <p><pre><code>from magicgui import widgets\nimport datetime\n\nwdg_list = [\n    widgets.Label(value=\"label value\", label=\"Label:\"),\n    widgets.LineEdit(value=\"line edit value\", label=\"LineEdit:\"),\n    widgets.Password(value=\"super-secret!\", label=\"Password:\"),\n    widgets.TextEdit(value=\"text edit value...\", label=\"TextEdit:\"),\n    widgets.FileEdit(value=\"/home\", label=\"FileEdit:\"),\n    widgets.RangeEdit(value=range(0, 10, 2), label=\"RangeEdit:\"),\n    widgets.SliceEdit(value=slice(0, 10, 2), label=\"SliceEdit:\"),\n    widgets.DateTimeEdit(\n      value=datetime.datetime(1999, 12, 31, 11, 30), label=\"DateTimeEdit:\"\n    ),\n    widgets.DateEdit(value=datetime.date(81, 2, 18), label=\"DateEdit:\"),\n    widgets.TimeEdit(value=datetime.time(12, 20), label=\"TimeEdit:\"),\n    widgets.QuantityEdit(value='12 seconds', label=\"Quantity:\")\n]\ncontainer = widgets.Container(widgets=wdg_list)\ncontainer.max_height = 300\ncontainer.show()\n</code></pre> </p>"},{"location":"widgets/#rangedwidget","title":"<code>RangedWidget</code>","text":"<p><code>RangedWidgets</code> are numerical <code>ValueWidgets</code> that have a restricted range of valid values, and a step size.  <code>RangedWidgets</code> include:</p> Widget Description <code>SpinBox</code> A widget to edit an integer with clickable up/down arrows. <code>FloatSpinBox</code> A widget to edit a float with clickable up/down arrows. <p>In addition to all of the <code>ValueWidget</code> attributes, <code>RangedWidget</code> attributes include:</p> Attribute Type Description <code>min</code> <code>float</code> The minimum allowable value, by default 0 <code>max</code> <code>float</code> The maximum allowable value, by default 1000 <code>step</code> <code>float</code> The step size for incrementing the value, by default 1 <code>range</code> <code>tuple of float</code> A convenience attribute for getting/setting the (min, max) simultaneously <p><pre><code>w1 = widgets.SpinBox(value=10, max=20, label='SpinBox:')\nw2 = widgets.FloatSpinBox(value=380, step=0.5, label='FloatSpinBox:')\ncontainer = widgets.Container(widgets=[w1, w2])\ncontainer.show()\n</code></pre> </p>"},{"location":"widgets/#sliderwidget","title":"<code>SliderWidget</code>","text":"<p><code>SliderWidgets</code> are special <code>RangedWidgets</code> that additionally have an <code>orientation</code>, and a <code>readout</code>.</p> Widget Description <code>Slider</code> A slider widget to adjust an integer value within a range. <code>FloatSlider</code> A slider widget to adjust an integer value within a range. <code>LogSlider</code> A slider widget to adjust a numerical value logarithmically within a range. <code>ProgressBar</code> A progress bar widget. <p>In addition to all of the <code>RangedWidget</code> attributes, <code>SliderWidget</code> attributes include:</p> Attribute Type Description <code>orientation</code> <code>str</code> The orientation for the slider. Must be either <code>'horizontal'</code> or <code>'vertical'</code>.  by default <code>'horizontal'</code> <code>readout</code> <code>bool</code> Whether to show the value of the slider. By default, <code>True</code>. <p><pre><code>w1 = widgets.Slider(value=10, max=25, label='Slider:')\nw2 = widgets.FloatSlider(value=10.5, max=18.5, label='FloatSlider:')\nw3 = widgets.ProgressBar(value=80, max=100, label='ProgressBar:')\ncontainer = widgets.Container(widgets=[w1, w2, w3])\ncontainer.show()\n</code></pre> </p>"},{"location":"widgets/#buttonwidget","title":"<code>ButtonWidget</code>","text":"<p><code>ButtonWidgets</code> are boolean <code>ValueWidgets</code> that also have some <code>text</code> associated with them.</p> Widget Description <code>PushButton</code> A clickable command button. <code>CheckBox</code> A checkbox with a text label. <p>In addition to all of the <code>ValueWidget</code> attributes, <code>ButtonWidget</code> attributes include:</p> Attribute Type Description <code>text</code> <code>str</code> The text to display on the button. If not provided, will use <code>name</code>. <p><pre><code>w1 = widgets.PushButton(value=True, text='PushButton Text')\nw2 = widgets.CheckBox(value=False, text='CheckBox Text')\ncontainer = widgets.Container(widgets=[w1, w2])\ncontainer.show()\n</code></pre> </p>"},{"location":"widgets/#categoricalwidget","title":"<code>CategoricalWidget</code>","text":"<p><code>CategoricalWidget</code> are <code>ValueWidgets</code> that provide a set of valid choices.  They can be created from:</p> <ul> <li>an <code>enum.Enum</code></li> <li>an iterable of objects (or an iterable of 2-tuples <code>(name, object)</code>)</li> <li>a callable that returns an <code>enum.Enum</code> or an iterable</li> <li>a <code>typing.Literal</code> annotation.</li> </ul> Widget Description <code>ComboBox</code> A dropdown menu, allowing selection between multiple choices. <code>RadioButtons</code> An exclusive group of radio buttons, providing a choice from multiple choices. <code>Select</code> A list of options, allowing selection between multiple choices. <p>In addition to all of the <code>ValueWidget</code> attributes, <code>CategoricalWidget</code> attributes include:</p> Attribute Type Description <code>choices</code> <code>Enum</code>, <code>Iterable</code>, or <code>Callable</code> Available choices displayed in the widget. <code>value</code> <code>Any</code> In the case of a <code>CategoricalWidget</code> the <code>value</code> is the data of the currently selected choice (see also: <code>current_choice</code> below). <code>current_choice</code> <code>str</code> The name associated with the current choice.  For instance, if <code>choices</code> was provided as <code>choices=[('one', 1), ('two', 2)]</code>, then an example <code>value</code> would be <code>1</code>, and an example <code>current_choice</code> would be <code>'one'</code>. <p><pre><code>choices = ['one', 'two', 'three']\nw1 = widgets.ComboBox(choices=choices, value='two', label='ComboBox:')\nw2 = widgets.RadioButtons(choices=choices, label='RadioButtons:')\nw3 = widgets.Select(choices=choices, label='Select:')\ncontainer = widgets.Container(widgets=[w1, w2, w3])\ncontainer.max_height = 220\ncontainer.show()\n</code></pre> </p>"},{"location":"widgets/#containerwidget","title":"<code>ContainerWidget</code>","text":"<p>A <code>ContainerWidget</code> is a list-like <code>Widget</code> that can contain other widgets. Containers allow you to build more complex widgets from sub-widgets. A notable example of a <code>Container</code> is <code>magicgui.widgets.FunctionGui</code>) (the product of the <code>@magicgui</code> decorator).</p> Widget Description <code>Container</code> A Widget to contain other widgets. <code>MainWindow</code> A Widget to contain other widgets, includes a menu bar. <code>FunctionGui</code> Wrapper for a container of widgets representing a callable object. Attribute Type Description <code>layout</code> <code>str</code> The layout for the container.  Must be either <code>'horizontal'</code> or <code>'vertical'</code>. <code>widgets</code> <code>Sequence[Widget]</code> The widgets that the container contains. <code>labels</code> <code>bool</code> Whether each widget should be shown with a corresponding <code>Label</code> widget to the left.  Note: the text for each widget defaults to <code>widget.name</code>, but can be overridden by setting <code>widget.label</code>. <p><code>Container</code> implements the full <code>collections.abc.MutableSequence</code> interface. You can add and remove widgets from it just as you would add or remove items from a list.</p> <p><pre><code>from magicgui.widgets import Container, Slider, FloatSlider, ProgressBar\n\ncontainer = widgets.Container()\ncontainer.append(widgets.LineEdit(value='Mookie', label='Your Name:'))\ncontainer.append(widgets.FloatSlider(value=10.5, label='FloatSlider:'))\ncontainer.show()\n</code></pre> </p>"},{"location":"widgets/#mainwindowwidget","title":"<code>MainWindowWidget</code>","text":"<p>A <code>MainWindowWidget</code> is a special type of <code>ContainerWidget</code> that also includes a menu bar.</p>"},{"location":"widgets/#functiongui","title":"<code>FunctionGui</code>","text":"<p>A <code>FunctionGui</code> is a special type of <code>ContainerWidget</code> that is created from a function.  It is the product of the <code>@magicgui</code> decorator.  It is a container that contains a widget for each of the parameters in the function. See <code>magicgui.widgets.FunctionGui</code> for details.</p>"},{"location":"widgets/#magicgui","title":"<code>@magicgui</code>","text":"<p>It's worth noting that <code>@magicgui</code> and <code>@magic_factory</code> decorators are just conveniences that build a special type of <code>Container</code> widget (a <code>FunctionGui</code>), with a widget representing each of the parameters in a decorated function.</p> <p><pre><code>from magicgui import magicgui\n\n@magicgui\ndef my_function(x='hello', y=400): ...\n\nmy_function.show()\n</code></pre> </p> <p>In terms of simply building widgets, the following code performs a similar task to <code>@magicgui</code>.</p> <p><pre><code>from inspect import signature\n\ndef my_function(x='hello', y=400):\n  ...\n\nparams = signature(my_function).parameters.values()\ncontainer = Container(\n    widgets=[create_widget(p.default, name=p.name) for p in params]\n)\ncontainer.show()\n</code></pre> </p> <p>Tip</p> <p>Note that the <code>FunctionGui</code> widget produced by <code>@magicgui</code> is actually a callable object that behaves very much like the original function, except that it will use current values from the GUI as default parameters when calling the function.</p>"},{"location":"api/app/","title":"Application","text":""},{"location":"api/app/#magicgui.application.Application","title":"<code>magicgui.application.Application</code>","text":"<p>Magicgui Application, wrapping a native BaseApplicationBackend implementation.</p>"},{"location":"api/app/#magicgui.application.Application.backend_module","title":"<code>backend_module: ModuleType</code>  <code>property</code>","text":"<p>Return module object that defines the backend.</p>"},{"location":"api/app/#magicgui.application.Application.backend_name","title":"<code>backend_name: str</code>  <code>property</code>","text":"<p>Return name of the GUI backend that this app wraps.</p>"},{"location":"api/app/#magicgui.application.Application.native","title":"<code>native: Any</code>  <code>property</code>","text":"<p>Return the native GUI application instance.</p>"},{"location":"api/app/#magicgui.application.Application.__enter__","title":"<code>__enter__() -&gt; Application</code>","text":"<p>Context manager to start this application.</p>"},{"location":"api/app/#magicgui.application.Application.__exit__","title":"<code>__exit__(*exc_details: Any) -&gt; None</code>","text":"<p>Exit context manager for this application.</p>"},{"location":"api/app/#magicgui.application.Application.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Return repr for this instance.</p>"},{"location":"api/app/#magicgui.application.Application.create","title":"<code>create() -&gt; None</code>","text":"<p>Create the native application.</p>"},{"location":"api/app/#magicgui.application.Application.get_obj","title":"<code>get_obj(name: str) -&gt; Any</code>","text":"<p>Get the backend object for the given <code>name</code> (such as a widget).</p>"},{"location":"api/app/#magicgui.application.Application.process_events","title":"<code>process_events() -&gt; None</code>","text":"<p>Process all pending GUI events.</p>"},{"location":"api/app/#magicgui.application.Application.quit","title":"<code>quit() -&gt; None</code>","text":"<p>Quit the native GUI event loop.</p>"},{"location":"api/app/#magicgui.application.Application.run","title":"<code>run() -&gt; None</code>","text":"<p>Enter the native GUI event loop.</p>"},{"location":"api/app/#magicgui.application.Application.start_timer","title":"<code>start_timer(interval: int = 1000, on_timeout: Callable[[], None] | None = None, single_shot: bool = False) -&gt; None</code>","text":"<p>Start a timer with a given interval, optional callback, and single_shot.</p>"},{"location":"api/app/#magicgui.application.use_app","title":"<code>magicgui.application.use_app(app: AppRef | None = None) -&gt; Application</code>","text":"<p>Get/create the default Application object.  See _use_app docstring.</p>"},{"location":"api/experimental/","title":"<code>magicgui.experimental</code>","text":"<p>Experimental</p> <p>This module contains experimental features that are not yet ready for prime time. All of the features in this module are subject to change without warning or deprecation.</p>"},{"location":"api/experimental/#magicgui.experimental.guiclass","title":"<code>magicgui.experimental.guiclass(cls: T | None = None, *, gui_name: str = 'gui', events_namespace: str = 'events', follow_changes: bool = True, **dataclass_kwargs: Any) -&gt; T | Callable[[T], T]</code>","text":"<p>Turn class into a dataclass with a property (<code>gui_name</code>) that returns a gui.</p> <p>This decorator is similar to <code>dataclasses.dataclass</code>, but it will also add an <code>events</code> attribute to the class that is an instance of <code>psygnal.SignalGroup</code> (with a signal for each field in the dataclass; see https://psygnal.readthedocs.io/en/latest/dataclasses/ for details), and a <code>gui</code> property that returns a <code>magicgui</code> widget, bound to the values of the dataclass instance.</p> <p>Note</p> <p>This decorator is compatible with dataclasses using <code>slots=True</code>, however, there is a potential for a memory leak that the user should be aware of. If you create a <code>guiclass</code> instance, and then store a reference to its <code>gui</code>, and then delete the instance, the <code>gui</code> will still be bound to the instance, preventing it from being garbage collected.  To avoid this, you can call <code>unbind_gui_from_instance(gui, instance)</code> before deleting the instance.</p> <p>Parameters:</p> <ul> <li> cls             (<code>type</code>, default:                 <code>None</code> )         \u2013          <p>The class to turn into a dataclass.</p> </li> <li> gui_name             (<code>str</code>, default:                 <code>'gui'</code> )         \u2013          <p>The name of the property that will return a <code>magicgui</code> widget, by default <code>\"gui\"</code></p> </li> <li> events_namespace             (<code>str</code>, default:                 <code>'events'</code> )         \u2013          <p>The name of the attribute that will be added to the class, by default \"events\". This attribute will be an instance of <code>psygnal.SignalGroup</code> that will be used to connect events to the class.</p> </li> <li> follow_changes             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>If <code>True</code> (default), changes to the dataclass instance will be reflected in the gui, and changes to the gui will be reflected in the dataclass instance.</p> </li> <li> dataclass_kwargs             (<code>dict</code>, default:                 <code>{}</code> )         \u2013          <p>Additional keyword arguments to pass to <code>dataclasses.dataclass</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>type</code>         \u2013          <p>The dataclass.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; @guiclass\n... class MyData:\n...     x: int = 0\n...     y: str = 'hi'\n...\n...     @button\n...     def reset(self):\n...         self.x = 0\n...         self.y = 'hi'\n...\n&gt;&gt;&gt; data = MyData()\n&gt;&gt;&gt; data.gui.show()\n</code></pre>"},{"location":"api/experimental/#magicgui.experimental.button","title":"<code>magicgui.experimental.button(func: F | None = None, **button_kwargs: Any) -&gt; F | Callable[[F], F]</code>","text":"<p>Add a method as a button to a <code>guiclass</code>, which calls the decorated method.</p> <p>Parameters:</p> <ul> <li> func             (<code>callable</code>, default:                 <code>None</code> )         \u2013          <p>The method to decorate.  If None, returns a decorator that can be applied to a method.</p> </li> <li> button_kwargs             (<code>dict</code>, default:                 <code>{}</code> )         \u2013          <p>Additional keyword arguments to pass to <code>magicgui.widgets.PushButton</code>.</p> </li> </ul>"},{"location":"api/experimental/#magicgui.experimental.is_guiclass","title":"<code>magicgui.experimental.is_guiclass(obj: object) -&gt; TypeGuard[GuiClassProtocol]</code>","text":"<p>Return <code>True</code> if obj is a guiclass or an instance of a guiclass.</p>"},{"location":"api/magic_factory/","title":"<code>magicgui.magic_factory</code>","text":""},{"location":"api/magic_factory/#magicgui.magic_factory","title":"<code>magicgui.magic_factory(function=None, *, layout='vertical', scrollable=False, labels=True, tooltips=True, call_button=None, auto_call=False, result_widget=False, main_window=False, app=None, persist=False, widget_init=None, raise_on_unknown=False, **param_options)</code>","text":"<p>Return a <code>MagicFactory</code> for function.</p> <p><code>magic_factory</code> is nearly identical to the <code>magicgui</code> decorator with the following differences:</p> <ol> <li>Whereas <code>magicgui</code> returns a <code>FunctionGui</code> instance, <code>magic_factory</code> returns a    callable that returns a <code>FunctionGui</code> instance.  (Technically, it returns an    instance of <code>MagicFactory</code> which you    behaves exactly like a <code>functools.partial</code>    for a <code>FunctionGui</code> instance.)</li> <li><code>magic_factory</code> adds a <code>widget_init</code> method: a callable that will be called     immediately after the <code>FunctionGui</code> instance is created.  This can be used to     add additional widgets to the layout, or to connect signals to the widgets.</li> </ol> <p>Important</p> <p>Whereas decorating a function with <code>magicgui</code> will immediately create a widget instance, <code>magic_factory</code> will not create a widget instance until the decorated object is called.  This is often what you want in a library, whereas <code>magicgui</code> is useful for rapid, interactive development.</p> <p>Parameters:</p> <ul> <li> function             (<code>Callable</code>, default:                 <code>None</code> )         \u2013          <p>The function to decorate.  Optional to allow bare decorator with optional arguments. by default <code>None</code></p> </li> <li> layout             (<code>str</code>, default:                 <code>'vertical'</code> )         \u2013          <p>The type of layout to use. Must be <code>horizontal</code> or <code>vertical</code> by default \"vertical\".</p> </li> <li> scrollable             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to enable scroll bars or not. If enabled, scroll bars will only appear along the layout direction, not in both directions.</p> </li> <li> labels             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether labels are shown in the widget. by default True</p> </li> <li> tooltips             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether tooltips are shown when hovering over widgets. by default True</p> </li> <li> call_button             (<code>bool or str</code>, default:                 <code>None</code> )         \u2013          <p>If <code>True</code>, create an additional button that calls the original function when clicked.  If a <code>str</code>, set the button text. If None (the default), it defaults to True when <code>auto_call</code> is False, and False otherwise.</p> </li> <li> auto_call             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, changing any parameter in either the GUI or the widget attributes will call the original function with the current settings. by default False</p> </li> <li> result_widget             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to display a LineEdit widget the output of the function when called, by default False</p> </li> <li> main_window             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether this widget should be treated as the main app window, with menu bar, by default False.</p> </li> <li> app             (<code>Application or str</code>, default:                 <code>None</code> )         \u2013          <p>A backend to use, by default <code>None</code> (use the default backend.)</p> </li> <li> persist             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, when parameter values change in the widget, they will be stored to disk and restored when the widget is loaded again with <code>persist = True</code>. Call <code>magicgui._util.user_cache_dir()</code> to get the default cache location. By default False.</p> </li> <li> widget_init             (<code>callable</code>, default:                 <code>None</code> )         \u2013          <p>A function that will be called with the newly created widget instance as its only argument.  This can be used to customize the widget after it is created. by default <code>None</code>.</p> </li> <li> raise_on_unknown             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, raise an error if magicgui cannot determine widget for function argument or return type. If <code>False</code>, ignore unknown types. By default False.</p> </li> <li> param_options             (<code>dict of dict</code>, default:                 <code>{}</code> )         \u2013          <p>Any additional keyword arguments will be used as parameter-specific widget options. Keywords must match the name of one of the arguments in the function signature, and the value must be a dict of keyword arguments to pass to the widget constructor.</p> </li> </ul> <p>Returns:</p> <ul> <li> result (            <code>MagicFactory or Callable[[F], MagicFactory]</code> )        \u2013          <p>If <code>function</code> is not <code>None</code> (such as when this is used as a bare decorator), returns a MagicFactory instance. If <code>function</code> is <code>None</code> such as when arguments are provided like <code>magic_factory(auto_call=True)</code>, then returns a function that can be used as a decorator.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; @magic_factory\n... def my_function(a: int = 1, b: str = 'hello'):\n...     pass\n...\n&gt;&gt;&gt; my_widget = my_function()\n&gt;&gt;&gt; my_widget.show()\n&gt;&gt;&gt; my_widget.a.value == 1  # True\n&gt;&gt;&gt; my_widget.b.value = 'world'\n</code></pre>"},{"location":"api/magic_factory/#magicgui.type_map._magicgui.MagicFactory","title":"<code>magicgui.type_map._magicgui.MagicFactory</code>","text":"<p>             Bases: <code>partial</code>, <code>Generic[_FGuiVar]</code></p> <p>Factory function that returns a FunctionGui instance.</p> <p>While this can be used directly, (see example below) the preferred usage is via the <code>magicgui.magic_factory</code> decorator.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; def func(x: int, y: str):\n...     pass\n...\n&gt;&gt;&gt; factory = MagicFactory(function=func, labels=False)\n&gt;&gt;&gt; # factory accepts all the same arguments as magicgui()\n&gt;&gt;&gt; widget1 = factory(call_button=True)\n&gt;&gt;&gt; # can also override magic_kwargs that were provided when creating the factory\n&gt;&gt;&gt; widget2 = factory(auto_call=True, labels=True)\n</code></pre>"},{"location":"api/magic_factory/#magicgui.type_map._magicgui.MagicFactory.__name__","title":"<code>__name__: str</code>  <code>property</code>","text":"<p>Pass function name.</p>"},{"location":"api/magic_factory/#magicgui.type_map._magicgui.MagicFactory.__call__","title":"<code>__call__(*args, **kwargs)</code>","text":"<p>Call the wrapped _magicgui and return a FunctionGui.</p>"},{"location":"api/magic_factory/#magicgui.type_map._magicgui.MagicFactory.__getattr__","title":"<code>__getattr__(name)</code>","text":"<p>Allow accessing FunctionGui attributes without mypy error.</p>"},{"location":"api/magic_factory/#magicgui.type_map._magicgui.MagicFactory.__new__","title":"<code>__new__(function, *args, magic_class=FunctionGui, widget_init=None, **keywords)</code>","text":"<p>Create new MagicFactory.</p>"},{"location":"api/magic_factory/#magicgui.type_map._magicgui.MagicFactory.__repr__","title":"<code>__repr__()</code>","text":"<p>Return string repr.</p>"},{"location":"api/magicgui/","title":"<code>magicgui.magicgui</code>","text":""},{"location":"api/magicgui/#magicgui.magicgui","title":"<code>magicgui.magicgui(function=None, *, layout='vertical', scrollable=False, labels=True, tooltips=True, call_button=None, auto_call=False, result_widget=False, main_window=False, app=None, persist=False, raise_on_unknown=False, **param_options)</code>","text":"<p>Return a <code>FunctionGui</code> for <code>function</code>.</p> <p>Parameters:</p> <ul> <li> function             (<code>Callable</code>, default:                 <code>None</code> )         \u2013          <p>The function to decorate.  Optional to allow bare decorator with optional arguments. by default <code>None</code></p> </li> <li> layout             (<code>str</code>, default:                 <code>'vertical'</code> )         \u2013          <p>The type of layout to use. Must be <code>horizontal</code> or <code>vertical</code> by default \"vertical\".</p> </li> <li> scrollable             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to enable scroll bars or not. If enabled, scroll bars will only appear along the layout direction, not in both directions.</p> </li> <li> labels             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether labels are shown in the widget. by default True</p> </li> <li> tooltips             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether tooltips are shown when hovering over widgets. by default True</p> </li> <li> call_button             (<code>bool or str</code>, default:                 <code>None</code> )         \u2013          <p>If <code>True</code>, create an additional button that calls the original function when clicked.  If a <code>str</code>, set the button text. If None (the default), it defaults to True when <code>auto_call</code> is False, and False otherwise.</p> </li> <li> auto_call             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, changing any parameter in either the GUI or the widget attributes will call the original function with the current settings. by default False</p> </li> <li> result_widget             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to display a LineEdit widget the output of the function when called, by default False</p> </li> <li> main_window             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether this widget should be treated as the main app window, with menu bar, by default False.</p> </li> <li> app             (<code>Application or str</code>, default:                 <code>None</code> )         \u2013          <p>A backend to use, by default <code>None</code> (use the default backend.)</p> </li> <li> persist             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, when parameter values change in the widget, they will be stored to disk and restored when the widget is loaded again with <code>persist = True</code>. Call <code>magicgui._util.user_cache_dir()</code> to get the default cache location. By default False.</p> </li> <li> raise_on_unknown             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, raise an error if magicgui cannot determine widget for function argument or return type. If <code>False</code>, ignore unknown types. By default False.</p> </li> <li> param_options             (<code>dict[str, dict]</code>, default:                 <code>{}</code> )         \u2013          <p>Any additional keyword arguments will be used as parameter-specific options. Keywords must match the name of one of the arguments in the function signature, and the value must be a dict of keyword arguments to pass to the widget constructor.</p> </li> </ul> <p>Returns:</p> <ul> <li> result (            <code>FunctionGui or Callable[[F], FunctionGui]</code> )        \u2013          <p>If <code>function</code> is not <code>None</code> (such as when this is used as a bare decorator), returns a FunctionGui instance, which is a list-like container of autogenerated widgets corresponding to each parameter in the function. If <code>function</code> is <code>None</code> such as when arguments are provided like <code>magicgui(auto_call=True)</code>, then returns a function that can be used as a decorator.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; @magicgui\n... def my_function(a: int = 1, b: str = 'hello'):\n...     pass\n...\n&gt;&gt;&gt; my_function.show()\n&gt;&gt;&gt; my_function.a.value == 1  # True\n&gt;&gt;&gt; my_function.b.value = 'world'\n</code></pre>"},{"location":"api/migration/","title":"migration guide","text":""},{"location":"api/migration/#v030-migration-guide","title":"v0.3.0 migration guide","text":"<p>October, 2021</p> <p>Version 0.3.0 of magicgui introduced some changes to the events and callbacks API. See https://github.com/pyapp-kit/magicgui/pull/253 for details</p>"},{"location":"api/migration/#callbacks-now-receive-the-value-directly-instead-of-an-event-object","title":"Callbacks now receive the value directly, instead of an <code>Event</code> object","text":"<p>magicgui 0.3.0 is now using psygnal as its event/callback handler.</p> <p>Callbacks connected to <code>widget.changed</code> (and other event emitters) may now receive the value(s) directly, instead of an event object:</p> \ud83d\udc4e Old Method (&lt; v0.3.0)<pre><code>@widget.changed.connect\ndef my_callback(event):\n    # event was an `Event` object with a `value` attribute\n    new_value = event.value\n</code></pre> <p>Existing code using callbacks with a single positional argument will continue to receive a single Event object (and a warning will be shown, until v0.4.0 where it will become an error).</p> <p>To silence the warning and opt in to the new pattern of receiving value directly, you can do one of two things:</p> <ol> <li>type hint your single positional argument as anything other than <code>magicgui.events.Event</code></li> <li>provide a callback that takes no arguments</li> </ol> \ud83d\udc4d New Method (&gt;= v0.3.0)<pre><code>@widget.changed.connect\ndef my_callback(new_value: int):\n    ...  # use new_value directly\n\n# or, if you don't need to use new_value\n@widget.changed.connect\ndef my_callback():\n    # something that didn't need the value\n    ...\n</code></pre>"},{"location":"api/migration/#event-emitters-take-no-keyword-arguments","title":"Event emitters take no keyword arguments","text":"<p>For the few packages who were manually emitting change events, you should no longer provide the <code>value=</code> keyword when emitting.</p> \ud83d\udc4e Old Method (&lt; v0.3.0)<pre><code>widget.changed(value='whatever')\n</code></pre> \ud83d\udc4d New Method (&gt;= v0.3.0)<pre><code>widget.changed.emit('whatever')\n# OR (if you prefer the direct __call__ syntax)\nwidget.changed('whatever')\n</code></pre>"},{"location":"api/migration/#v020-migration-guide","title":"v0.2.0 migration guide","text":"<p>December, 2020</p> <p>Version 0.2.0 of magicgui was a complete rewrite that introduced a couple breaking API changes</p>"},{"location":"api/migration/#gui-attribute-removed","title":"<code>.Gui()</code> attribute removed","text":"<p>Before <code>v0.2.0</code>, the <code>magicgui.magicgui</code> decorator added a <code>Gui</code> attribute to the decorated function that was to be called to instantiate a widget.  In <code>v0.2.0</code> the object returned from the <code>magicgui.magicgui</code> decorator is already an instantiated <code>magicgui.widgets.Widget</code>.</p> \ud83d\udc4e Old Method (&lt; v0.2.0)<pre><code>from magicgui import magicgui, event_loop\n\n@magicgui\ndef function(x, y):\n    ...\n\nwith event_loop():\n    gui = function.Gui(show=True)\n</code></pre> \ud83d\udc4d New Method (&gt;= v0.2.0)<pre><code>from magicgui import magicgui\n\n@magicgui\ndef function(x, y):\n    ...\n\nfunction.show(run=True)\n</code></pre>"},{"location":"api/migration/#new-base-widget-type","title":"New base widget type","text":"<p>Before <code>v0.2.0</code>, the <code>Gui()</code> object returned by the <code>magicgui.magicgui</code> decorator was a <code>MagicGuiBase</code> widget class, which in turn was a direct subclass of a backend widget, such as a <code>QtWidgets.QWidget</code>.  In <code>v0.2.0</code>, all widgets derive from [<code>magicgui.widgets.Widget``][magicgui.widgets.Widget], and the *backend* is available at</code>widget.native<code>.  If you are incorporating magicgui widgets into a larger Qt-based GUI, please note that you will want to use</code>widget.native<code>instead of</code>widget`</p> <pre><code>from magicgui import magicgui, use_app\n\nuse_app('qt')\n\n@magicgui\ndef function(x, y):\n    ...\n</code></pre> <pre><code>&gt;&gt;&gt; print(type(function))\n&lt;class 'magicgui.widgets.FunctionGui'&gt;\n&gt;&gt;&gt; print(type(function.native))\n&lt;class 'PyQt5.QtWidgets.QWidget'&gt;\n</code></pre>"},{"location":"api/migration/#starting-the-application","title":"Starting the application","text":"<p>It is now easier to show a widget and start an application by calling <code>widget.show(run=True)</code>. Calling <code>show(run=True)</code> will immediately block execution of your script and show the widget.  If you wanted to (for instance) show multiple widgets next to each other, then you would still want to use the <code>event_loop</code> context manager:</p> <pre><code>from magicgui import magicgui, event_loop\n\n@magicgui\ndef function_a(x=1, y=3):\n    ...\n\n@magicgui\ndef function_b(z='asdf'):\n    ...\n\nwith event_loop():\n    function_a.show()\n    function_b.show()\n# both widgets will show (though b may be on top of a)\n</code></pre>"},{"location":"api/migration/#getting-and-setting-values","title":"Getting and setting values","text":"<p>To get or set the value of a widget programmatically, you no longer set the corresponding widget attribute directly, but rather use the <code>widget.value</code> attribute:</p> <p>Old Method \ud83d\udc4e</p> <p><code>gui.x</code> used to be a descriptor object to get/set the value, but the actual underlying widget was at <code>gui.x_widget</code></p> <pre><code>gui = function.Gui()\ngui.x = 10\n</code></pre> <p>New Method \ud83d\udc4d</p> <p>now <code>function.x</code> IS the widget, and you set its value with <code>function.x.value</code></p> <pre><code>function.x.value = 10\n</code></pre>"},{"location":"api/migration/#connecting-callbacks-to-events","title":"Connecting callbacks to events","text":"<p>When binding callbacks to change events, you no longer connect to <code>gui.&lt;name&gt;_changed</code>, you now connect to <code>function.&lt;name&gt;.changed</code>:</p> \ud83d\udc4e Old Method (&lt; v0.2.0)<pre><code>gui = function.Gui()\ngui.x_changed.connect(my_callback)\n</code></pre> \ud83d\udc4d New Method (&gt;= v0.2.0)<pre><code>function.x.changed.connect(my_callback)\n</code></pre>"},{"location":"api/migration/#renamed","title":"Renamed","text":"<ul> <li> <p><code>Widget.refresh_choices</code> has been renamed to <code>Widget.reset_choices</code>.</p> </li> <li> <p><code>@magicgui(result=True)</code> has been renamed to <code>@magicgui(result_widget=True)</code></p> </li> </ul>"},{"location":"api/protocols/","title":"Backend Protocols","text":"<p>Advanced Topic</p> <p>Most users of magicgui will not need to worry about this section.</p> <p>These Protocol classes declare the interface that backend adapters must implement in order to be used by magicgui. All magicgui <code>Widget</code> objects compose a backend widget implementing one of these protocols, and control it using the methods defined herein.</p> <p><code>magicgui</code> developers may be interested in this page, but end-users needn't worry about it.</p>"},{"location":"api/protocols/#summary","title":"Summary","text":"Widget Description <code>WidgetProtocol</code> Base Widget Protocol: specifies methods that all widgets must provide. <code>ValueWidgetProtocol</code> Widget that has a current value, with getter/setter and on_change callback. <code>ButtonWidgetProtocol</code> The \"value\" in a ButtonWidget is the current (checked) state. <code>TableWidgetProtocol</code> ValueWidget subclass intended for 2D tabular data, with row &amp; column headers. <code>RangedWidgetProtocol</code> Value widget that supports numbers within a provided min/max range. <code>CategoricalWidgetProtocol</code> Categorical widget, that has a set of valid choices, and a current value. <code>SliderWidgetProtocol</code> Protocol for implementing a slider widget. <code>ContainerProtocol</code> Widget that can contain other widgets. <code>BaseApplicationBackend</code> Backend Application object. <code>DialogProtocol</code> Protocol for modal (blocking) containers. <code>SupportsChoices</code> Widget that has a set of valid choices. <code>SupportsOrientation</code> Widget that can be reoriented. <code>SupportsText</code> Widget that have text (in addition to value)... like buttons. <code>SupportsReadOnly</code> Widget that can be read_only."},{"location":"api/protocols/#protocol-inheritance","title":"Protocol Inheritance","text":"<p>The visual hierarchy of protocols looks like this:</p> <pre><code>graph LR\n    A([WidgetProtocol])--&gt;B([ValueWidgetProtocol])\n    A--&gt;C([ContainerProtocol])\n    M([SupportsText])--&gt;E\n    B--&gt;E([ButtonWidgetProtocol])\n    B--&gt;D([RangedWidgetProtocol])\n    B--&gt;F([CategoricalWidgetProtocol])\n    D--&gt;I([SliderWidgetProtocol])\n    B--&gt;J([TableWidgetProtocol])\n    K([SupportsReadOnly])--&gt;J([TableWidgetProtocol])\n    L([SupportsChoices])--&gt;F\n    N([SupportsOrientation])--&gt;C\n    N--&gt;I\n    C--&gt;O([DialogProtocol])\n    C--&gt;P([MainWindowProtocol])\n\n    click A \"#magicgui.widgets.protocols.WidgetProtocol\"\n    click B \"#magicgui.widgets.protocols.ValueWidgetProtocol\"\n    click C \"#magicgui.widgets.protocols.ContainerProtocol\"\n    click D \"#magicgui.widgets.protocols.RangedWidgetProtocol\"\n    click E \"#magicgui.widgets.protocols.ButtonWidgetProtocol\"\n    click F \"#magicgui.widgets.protocols.CategoricalWidgetProtocol\"\n    click I \"#magicgui.widgets.protocols.SliderWidgetProtocol\"\n    click J \"#magicgui.widgets.protocols.TableWidgetProtocol\"\n    click K \"#magicgui.widgets.protocols.SupportsReadOnly\"\n    click L \"#magicgui.widgets.protocols.SupportsChoices\"\n    click M \"#magicgui.widgets.protocols.SupportsText\"\n    click N \"#magicgui.widgets.protocols.SupportsOrientation\"\n    click O \"#magicgui.widgets.protocols.DialogProtocol\"\n    click P \"#magicgui.widgets.protocols.MainWindowProtocol\"</code></pre>"},{"location":"api/protocols/#widget-protocols","title":"Widget Protocols","text":""},{"location":"api/protocols/#magicgui.widgets.protocols.WidgetProtocol","title":"<code>magicgui.widgets.protocols.WidgetProtocol</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>Base Widget Protocol: specifies methods that all widgets must provide.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.WidgetProtocol._mgui_bind_parent_change_callback","title":"<code>_mgui_bind_parent_change_callback(callback: Callable[[Any], None]) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Bind callback to parent change event.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.WidgetProtocol._mgui_close_widget","title":"<code>_mgui_close_widget() -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Close widget.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.WidgetProtocol._mgui_get_enabled","title":"<code>_mgui_get_enabled() -&gt; bool</code>  <code>abstractmethod</code>","text":"<p>Get the enabled state of the widget.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.WidgetProtocol._mgui_get_height","title":"<code>_mgui_get_height() -&gt; int</code>  <code>abstractmethod</code>","text":"<p>Get the height of the widget.</p> <p>The intention is to get the height of the widget after it is shown, for the purpose of unifying widget height in a layout. Backends may do what they need to accomplish this. For example, Qt can use <code>sizeHint().height()</code>, since <code>height()</code> may return something large if the widget has not yet been painted on screen.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.WidgetProtocol._mgui_get_max_height","title":"<code>_mgui_get_max_height() -&gt; int</code>  <code>abstractmethod</code>","text":"<p>Get the maximum height of the widget.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.WidgetProtocol._mgui_get_max_width","title":"<code>_mgui_get_max_width() -&gt; int</code>  <code>abstractmethod</code>","text":"<p>Get the maximum width of the widget.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.WidgetProtocol._mgui_get_min_height","title":"<code>_mgui_get_min_height() -&gt; int</code>  <code>abstractmethod</code>","text":"<p>Get the minimum height of the widget.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.WidgetProtocol._mgui_get_min_width","title":"<code>_mgui_get_min_width() -&gt; int</code>  <code>abstractmethod</code>","text":"<p>Get the minimum width of the widget.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.WidgetProtocol._mgui_get_native_widget","title":"<code>_mgui_get_native_widget() -&gt; Any</code>  <code>abstractmethod</code>","text":"<p>Return the native backend widget instance.</p> <p>This is generally the widget that has the layout.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.WidgetProtocol._mgui_get_parent","title":"<code>_mgui_get_parent() -&gt; Widget</code>  <code>abstractmethod</code>","text":"<p>Return the parent widget of this widget.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.WidgetProtocol._mgui_get_root_native_widget","title":"<code>_mgui_get_root_native_widget() -&gt; Any</code>  <code>abstractmethod</code>","text":"<p>Return the root native backend widget.</p> <p>In most cases, this is the same as <code>_mgui_get_native_widget</code>.  However, in cases where the native widget is in a scroll layout, this might be different.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.WidgetProtocol._mgui_get_tooltip","title":"<code>_mgui_get_tooltip() -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Get the tooltip for this widget.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.WidgetProtocol._mgui_get_visible","title":"<code>_mgui_get_visible() -&gt; bool</code>  <code>abstractmethod</code>","text":"<p>Get widget visibility.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.WidgetProtocol._mgui_get_width","title":"<code>_mgui_get_width() -&gt; int</code>  <code>abstractmethod</code>","text":"<p>Get the width of the widget.</p> <p>The intention is to get the width of the widget after it is shown, for the purpose of unifying widget width in a layout. Backends may do what they need to accomplish this. For example, Qt can use <code>sizeHint().width()</code>, since <code>width()</code> may return something large if the widget has not yet been painted on screen.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.WidgetProtocol._mgui_render","title":"<code>_mgui_render() -&gt; np.ndarray</code>  <code>abstractmethod</code>","text":"<p>Return an RGBA (MxNx4) numpy array bitmap of the rendered widget.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.WidgetProtocol._mgui_set_enabled","title":"<code>_mgui_set_enabled(enabled: bool) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Set the enabled state of the widget to <code>enabled</code>.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.WidgetProtocol._mgui_set_height","title":"<code>_mgui_set_height(value: int) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Set the height of the widget.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.WidgetProtocol._mgui_set_max_height","title":"<code>_mgui_set_max_height(value: int) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Set the maximum height of the widget.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.WidgetProtocol._mgui_set_max_width","title":"<code>_mgui_set_max_width(value: int) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Set the maximum width of the widget.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.WidgetProtocol._mgui_set_min_height","title":"<code>_mgui_set_min_height(value: int) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Set the minimum height of the widget.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.WidgetProtocol._mgui_set_min_width","title":"<code>_mgui_set_min_width(value: int) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Set the minimum width of the widget.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.WidgetProtocol._mgui_set_parent","title":"<code>_mgui_set_parent(widget: Widget) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Set the parent widget of this widget.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.WidgetProtocol._mgui_set_tooltip","title":"<code>_mgui_set_tooltip(value: str | None) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Set a tooltip for this widget.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.WidgetProtocol._mgui_set_visible","title":"<code>_mgui_set_visible(value: bool) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Set widget visibility.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.WidgetProtocol._mgui_set_width","title":"<code>_mgui_set_width(value: int) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Set the width of the widget.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.ValueWidgetProtocol","title":"<code>magicgui.widgets.protocols.ValueWidgetProtocol</code>","text":"<p>             Bases: <code>WidgetProtocol</code>, <code>Protocol</code></p> <p>Widget that has a current value, with getter/setter and on_change callback.</p> <p>It is worth noting that the widget is the thing that has a value.  Magicgui does not maintain &amp; synchronize an independent model.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.ValueWidgetProtocol._mgui_bind_change_callback","title":"<code>_mgui_bind_change_callback(callback: Callable[[Any], Any]) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Bind callback to value change event.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.ValueWidgetProtocol._mgui_get_value","title":"<code>_mgui_get_value() -&gt; Any</code>  <code>abstractmethod</code>","text":"<p>Get current value of the widget.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.ValueWidgetProtocol._mgui_set_value","title":"<code>_mgui_set_value(value: Any) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Set current value of the widget.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.ButtonWidgetProtocol","title":"<code>magicgui.widgets.protocols.ButtonWidgetProtocol</code>","text":"<p>             Bases: <code>ValueWidgetProtocol</code>, <code>SupportsText</code>, <code>SupportsIcon</code>, <code>Protocol</code></p> <p>The \"value\" in a ButtonWidget is the current (checked) state.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.TableWidgetProtocol","title":"<code>magicgui.widgets.protocols.TableWidgetProtocol</code>","text":"<p>             Bases: <code>ValueWidgetProtocol</code>, <code>SupportsReadOnly</code>, <code>Protocol</code></p> <p>ValueWidget subclass intended for 2D tabular data, with row &amp; column headers.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.TableWidgetProtocol._mgui_bind_change_callback","title":"<code>_mgui_bind_change_callback(callback: Callable[[Any], Any]) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Bind callback to value change event.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.TableWidgetProtocol._mgui_bind_column_headers_change_callback","title":"<code>_mgui_bind_column_headers_change_callback(callback: Callable[[Any], None]) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Bind callback to column headers change event.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.TableWidgetProtocol._mgui_bind_row_headers_change_callback","title":"<code>_mgui_bind_row_headers_change_callback(callback: Callable[[Any], None]) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Bind callback to row headers change event.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.TableWidgetProtocol._mgui_get_cell","title":"<code>_mgui_get_cell(row: int, col: int) -&gt; Any</code>  <code>abstractmethod</code>","text":"<p>Get current value of the widget.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.TableWidgetProtocol._mgui_get_column_count","title":"<code>_mgui_get_column_count() -&gt; int</code>  <code>abstractmethod</code>","text":"<p>Get the number of columns in the table.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.TableWidgetProtocol._mgui_get_column_headers","title":"<code>_mgui_get_column_headers() -&gt; tuple</code>  <code>abstractmethod</code>","text":"<p>Get current column headers of the widget.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.TableWidgetProtocol._mgui_get_row_count","title":"<code>_mgui_get_row_count() -&gt; int</code>  <code>abstractmethod</code>","text":"<p>Get the number of rows in the table.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.TableWidgetProtocol._mgui_get_row_headers","title":"<code>_mgui_get_row_headers() -&gt; tuple</code>  <code>abstractmethod</code>","text":"<p>Get current row headers of the widget.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.TableWidgetProtocol._mgui_remove_column","title":"<code>_mgui_remove_column(column: int) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Remove column at index <code>column</code>.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.TableWidgetProtocol._mgui_remove_row","title":"<code>_mgui_remove_row(row: int) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Remove row at index <code>row</code>.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.TableWidgetProtocol._mgui_set_cell","title":"<code>_mgui_set_cell(row: int, col: int, value: Any) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Set current value of the widget.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.TableWidgetProtocol._mgui_set_column_count","title":"<code>_mgui_set_column_count(ncols: int) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Set the number of columns in the table. (Create/delete as needed).</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.TableWidgetProtocol._mgui_set_column_headers","title":"<code>_mgui_set_column_headers(headers: Sequence) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Set current column headers of the widget.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.TableWidgetProtocol._mgui_set_row_count","title":"<code>_mgui_set_row_count(nrows: int) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Set the number of rows in the table. (Create/delete as needed).</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.TableWidgetProtocol._mgui_set_row_headers","title":"<code>_mgui_set_row_headers(headers: Sequence) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Set current row headers of the widget.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.RangedWidgetProtocol","title":"<code>magicgui.widgets.protocols.RangedWidgetProtocol</code>","text":"<p>             Bases: <code>ValueWidgetProtocol</code>, <code>Protocol</code></p> <p>Value widget that supports numbers within a provided min/max range.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.RangedWidgetProtocol._mgui_get_adaptive_step","title":"<code>_mgui_get_adaptive_step() -&gt; bool</code>  <code>abstractmethod</code>","text":"<p>Get adaptive step status.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.RangedWidgetProtocol._mgui_get_max","title":"<code>_mgui_get_max() -&gt; float</code>  <code>abstractmethod</code>","text":"<p>Get the maximum possible value.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.RangedWidgetProtocol._mgui_get_min","title":"<code>_mgui_get_min() -&gt; float</code>  <code>abstractmethod</code>","text":"<p>Get the minimum possible value.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.RangedWidgetProtocol._mgui_get_step","title":"<code>_mgui_get_step() -&gt; float</code>  <code>abstractmethod</code>","text":"<p>Get the step size.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.RangedWidgetProtocol._mgui_set_adaptive_step","title":"<code>_mgui_set_adaptive_step(value: bool) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Set adaptive step status.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.RangedWidgetProtocol._mgui_set_max","title":"<code>_mgui_set_max(value: float) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Set the maximum possible value.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.RangedWidgetProtocol._mgui_set_min","title":"<code>_mgui_set_min(value: float) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Set the minimum possible value.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.RangedWidgetProtocol._mgui_set_step","title":"<code>_mgui_set_step(value: float) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Set the step size.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.CategoricalWidgetProtocol","title":"<code>magicgui.widgets.protocols.CategoricalWidgetProtocol</code>","text":"<p>             Bases: <code>ValueWidgetProtocol</code>, <code>SupportsChoices</code>, <code>Protocol</code></p> <p>Categorical widget, that has a set of valid choices, and a current value.</p> <p>It adds no additional methods.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.SliderWidgetProtocol","title":"<code>magicgui.widgets.protocols.SliderWidgetProtocol</code>","text":"<p>             Bases: <code>RangedWidgetProtocol</code>, <code>SupportsOrientation</code>, <code>Protocol</code></p> <p>Protocol for implementing a slider widget.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.SliderWidgetProtocol._mgui_get_tracking","title":"<code>_mgui_get_tracking() -&gt; bool</code>","text":"<p>If tracking is False, changed is only emitted when released.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.SliderWidgetProtocol._mgui_set_readout_visibility","title":"<code>_mgui_set_readout_visibility(visible: bool) -&gt; None</code>","text":"<p>Set visibility of readout widget.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.SliderWidgetProtocol._mgui_set_tracking","title":"<code>_mgui_set_tracking(tracking: bool) -&gt; None</code>","text":"<p>If tracking is False, changed is only emitted when released.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.ContainerProtocol","title":"<code>magicgui.widgets.protocols.ContainerProtocol</code>","text":"<p>             Bases: <code>WidgetProtocol</code>, <code>SupportsOrientation</code>, <code>Protocol</code></p> <p>Widget that can contain other widgets.</p> <p>This generally manages a backend Layout.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.ContainerProtocol._mgui_get_margins","title":"<code>_mgui_get_margins() -&gt; tuple[int, int, int, int]</code>  <code>abstractmethod</code>","text":"<p>Get the margins of the container.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.ContainerProtocol._mgui_insert_widget","title":"<code>_mgui_insert_widget(position: int, widget: Widget) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Insert <code>widget</code> at the given <code>position</code> in the layout.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.ContainerProtocol._mgui_remove_widget","title":"<code>_mgui_remove_widget(widget: Widget) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Remove the specified widget.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.ContainerProtocol._mgui_set_margins","title":"<code>_mgui_set_margins(margins: tuple[int, int, int, int]) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Set the margins of the container.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.DialogProtocol","title":"<code>magicgui.widgets.protocols.DialogProtocol</code>","text":"<p>             Bases: <code>ContainerProtocol</code>, <code>Protocol</code></p> <p>Protocol for modal (blocking) containers.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.DialogProtocol._mgui_exec","title":"<code>_mgui_exec() -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Show the dialog and block.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.MainWindowProtocol","title":"<code>magicgui.widgets.protocols.MainWindowProtocol</code>","text":"<p>             Bases: <code>ContainerProtocol</code>, <code>Protocol</code></p> <p>Application main widget.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.MainWindowProtocol._mgui_create_menu_item","title":"<code>_mgui_create_menu_item(menu_name: str, action_name: str, callback: Callable | None = None, shortcut: str | None = None) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Create a new menu item.</p> <p>Parameters:</p> <ul> <li> menu_name             (<code>str</code>)         \u2013          <p>The name of the menu to add the item to.</p> </li> <li> action_name             (<code>str</code>)         \u2013          <p>The name of the action to add.</p> </li> <li> callback             (<code>Callable | None</code>, default:                 <code>None</code> )         \u2013          <p>A callback to be called when the action is triggered, by default None.</p> </li> <li> shortcut             (<code>str | None</code>, default:                 <code>None</code> )         \u2013          <p>A keyboard shortcut for the action, by default None.</p> </li> </ul>"},{"location":"api/protocols/#magicgui.widgets.protocols.SupportsChoices","title":"<code>magicgui.widgets.protocols.SupportsChoices</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>Widget that has a set of valid choices.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.SupportsChoices._mgui_del_choice","title":"<code>_mgui_del_choice(choice_name: str) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Delete the provided <code>choice_name</code> and associated data.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.SupportsChoices._mgui_get_choice","title":"<code>_mgui_get_choice(choice_name: str) -&gt; Any</code>  <code>abstractmethod</code>","text":"<p>Get data for a single choice.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.SupportsChoices._mgui_get_choices","title":"<code>_mgui_get_choices() -&gt; tuple[tuple[str, Any], ...]</code>  <code>abstractmethod</code>","text":"<p>Get available choices.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.SupportsChoices._mgui_get_count","title":"<code>_mgui_get_count() -&gt; int</code>  <code>abstractmethod</code>","text":"<p>Return number of choices.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.SupportsChoices._mgui_get_current_choice","title":"<code>_mgui_get_current_choice() -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Return the text of the currently selected choice.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.SupportsChoices._mgui_set_choice","title":"<code>_mgui_set_choice(choice_name: str, data: Any) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Set data for choice_name, or add a new item if choice_name doesn't exist.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.SupportsChoices._mgui_set_choices","title":"<code>_mgui_set_choices(choices: Iterable[tuple[str, Any]]) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Set available choices.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.SupportsOrientation","title":"<code>magicgui.widgets.protocols.SupportsOrientation</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>Widget that can be reoriented.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.SupportsOrientation._mgui_get_orientation","title":"<code>_mgui_get_orientation() -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Get orientation, return either 'horizontal' or 'vertical'.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.SupportsOrientation._mgui_set_orientation","title":"<code>_mgui_set_orientation(value: str) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Set orientation, value will be 'horizontal' or 'vertical'.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.SupportsText","title":"<code>magicgui.widgets.protocols.SupportsText</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>Widget that have text (in addition to value)... like buttons.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.SupportsText._mgui_get_text","title":"<code>_mgui_get_text() -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Get text.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.SupportsText._mgui_set_text","title":"<code>_mgui_set_text(value: str) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Set text.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.SupportsReadOnly","title":"<code>magicgui.widgets.protocols.SupportsReadOnly</code>","text":"<p>             Bases: <code>Protocol</code></p> <p>Widget that can be read_only.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.SupportsReadOnly._mgui_get_read_only","title":"<code>_mgui_get_read_only() -&gt; bool</code>  <code>abstractmethod</code>","text":"<p>Get read_only status.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.SupportsReadOnly._mgui_set_read_only","title":"<code>_mgui_set_read_only(value: bool) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Set read_only.</p>"},{"location":"api/protocols/#application-protocol","title":"Application Protocol","text":""},{"location":"api/protocols/#magicgui.widgets.protocols.BaseApplicationBackend","title":"<code>magicgui.widgets.protocols.BaseApplicationBackend</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Backend Application object.</p> <p>Abstract class that provides an interface between backends and <code>Application</code>. Each backend must implement a subclass of <code>BaseApplicationBackend</code>, and implement all of its <code>_mgui_xxx</code> methods.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.BaseApplicationBackend._mgui_get_backend_name","title":"<code>_mgui_get_backend_name() -&gt; str</code>  <code>abstractmethod</code>","text":"<p>Return the name of the backend.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.BaseApplicationBackend._mgui_get_native_app","title":"<code>_mgui_get_native_app() -&gt; Any</code>  <code>abstractmethod</code>","text":"<p>Return the native GUI application instance.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.BaseApplicationBackend._mgui_process_events","title":"<code>_mgui_process_events() -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Process all pending GUI events.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.BaseApplicationBackend._mgui_quit","title":"<code>_mgui_quit() -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Quit the native GUI event loop.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.BaseApplicationBackend._mgui_run","title":"<code>_mgui_run() -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Start the application.</p>"},{"location":"api/protocols/#magicgui.widgets.protocols.BaseApplicationBackend._mgui_start_timer","title":"<code>_mgui_start_timer(interval: int = 0, on_timeout: Callable[[], None] | None = None, single: bool = False) -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Create and start a timer.</p> <p>Parameters:</p> <ul> <li> interval             (<code>int</code>, default:                 <code>0</code> )         \u2013          <p>Interval between timeouts, by default 0</p> </li> <li> on_timeout             (<code>Optional[Callable[[], None]]</code>, default:                 <code>None</code> )         \u2013          <p>Function to call when timer finishes, by default None</p> </li> <li> single             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether the timer should only fire once, by default False</p> </li> </ul>"},{"location":"api/protocols/#magicgui.widgets.protocols.BaseApplicationBackend._mgui_stop_timer","title":"<code>_mgui_stop_timer() -&gt; None</code>  <code>abstractmethod</code>","text":"<p>Stop timer.  Should check for the existence of the timer.</p>"},{"location":"api/type_map/","title":"magicgui.type_map","text":"Widget Description <code>get_widget_class</code> Return a Widget subclass for the <code>value</code>/<code>annotation</code>. <code>register_type</code> Register a <code>widget_type</code> to be used for all parameters with type <code>type_</code>. <code>type_registered</code> Context manager that temporarily registers a widget type for a given <code>type_</code>. <code>type2callback</code> Return any callbacks that have been registered for <code>type_</code>."},{"location":"api/type_map/#magicgui.type_map.get_widget_class","title":"<code>magicgui.type_map.get_widget_class(value: Any = Undefined, annotation: Any = Undefined, options: dict | None = None, is_result: bool = False, raise_on_unknown: bool = True) -&gt; tuple[WidgetClass, dict]</code>","text":"<p>Return a Widget subclass for the <code>value</code>/<code>annotation</code>.</p> <p>Parameters:</p> <ul> <li> value             (<code>Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>A python value.  Will be used to determine the widget type if an <code>annotation</code> is not explicitly provided by default None</p> </li> <li> annotation             (<code>Optional[Type]</code>, default:                 <code>Undefined</code> )         \u2013          <p>A type annotation, by default None</p> </li> <li> options             (<code>dict</code>, default:                 <code>None</code> )         \u2013          <p>Options to pass when constructing the widget, by default {}</p> </li> <li> is_result             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Identifies whether the returned widget should be tailored to an input or to an output.</p> </li> <li> raise_on_unknown             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Raise exception if no widget is found for the given type, by default True</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Tuple[WidgetClass, dict]</code>         \u2013          <p>The WidgetClass, and dict that can be used for params. dict may be different than the options passed in.</p> </li> </ul>"},{"location":"api/type_map/#magicgui.type_map.register_type","title":"<code>magicgui.type_map.register_type(type_: _T | None = None, *, widget_type: WidgetRef | None = None, return_callback: ReturnCallback | None = None, **options: Any) -&gt; _T | Callable[[_T], _T]</code>","text":"<p>Register a <code>widget_type</code> to be used for all parameters with type <code>type_</code>.</p> <p>Note: registering a Union (or Optional) type effectively registers all types in the union with the arguments.</p> <p>Parameters:</p> <ul> <li> type_             (<code>type</code>, default:                 <code>None</code> )         \u2013          <p>The type for which a widget class or return callback will be provided.</p> </li> <li> widget_type             (<code>WidgetRef</code>, default:                 <code>None</code> )         \u2013          <p>A widget class from the current backend that should be used whenever <code>type_</code> is used as the type annotation for an argument in a decorated function, by default None</p> </li> <li> return_callback             (<code>ReturnCallback | None</code>, default:                 <code>None</code> )         \u2013          <p>If provided, whenever <code>type_</code> is declared as the return type of a decorated function, <code>return_callback(widget, value, return_type)</code> will be called whenever the decorated function is called... where <code>widget</code> is the Widget instance, and <code>value</code> is the return value of the decorated function.</p> </li> <li> options             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>key value pairs where the keys are valid <code>dict</code></p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>           \u2013          <p>If none of <code>widget_type</code>, <code>return_callback</code>, <code>bind</code> or <code>choices</code> are provided.</p> </li> </ul>"},{"location":"api/type_map/#magicgui.type_map.type_registered","title":"<code>magicgui.type_map.type_registered(type_: _T, *, widget_type: WidgetRef | None = None, return_callback: ReturnCallback | None = None, **options: Any) -&gt; Iterator[None]</code>","text":"<p>Context manager that temporarily registers a widget type for a given <code>type_</code>.</p> <p>When the context is exited, the previous widget type associations for <code>type_</code> is restored.</p> <p>Parameters:</p> <ul> <li> type_             (<code>_T</code>)         \u2013          <p>The type for which a widget class or return callback will be provided.</p> </li> <li> widget_type             (<code>Optional[WidgetRef]</code>, default:                 <code>None</code> )         \u2013          <p>A widget class from the current backend that should be used whenever <code>type_</code> is used as the type annotation for an argument in a decorated function, by default None</p> </li> <li> return_callback             (<code>ReturnCallback | None</code>, default:                 <code>None</code> )         \u2013          <p>If provided, whenever <code>type_</code> is declared as the return type of a decorated function, <code>return_callback(widget, value, return_type)</code> will be called whenever the decorated function is called... where <code>widget</code> is the Widget instance, and <code>value</code> is the return value of the decorated function.</p> </li> <li> options             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>key value pairs where the keys are valid <code>dict</code></p> </li> </ul>"},{"location":"api/type_map/#magicgui.type_map.type2callback","title":"<code>magicgui.type_map.type2callback(type_: type) -&gt; list[ReturnCallback]</code>","text":"<p>Return any callbacks that have been registered for <code>type_</code>.</p> <p>Parameters:</p> <ul> <li> type_             (<code>type</code>)         \u2013          <p>The type_ to look up.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list of callable</code>         \u2013          <p>Where a return callback accepts two arguments (gui, value) and does something.</p> </li> </ul>"},{"location":"api/widgets/","title":"Widget Index","text":"<p>Here you will find a list of all the widgets that are available in magicgui. Each widget has a link to its own documentation page, where you can find more information about the widget, including its parameters and events.</p> Widget Description <code>CheckBox</code> A checkbox with a text label. <code>ComboBox</code> A dropdown menu, allowing selection between multiple choices. <code>Container</code> A Widget to contain other widgets. <code>DateEdit</code> A widget for editing dates. <code>DateTimeEdit</code> A widget for editing dates and times. <code>Dialog</code> A modal container. <code>EmptyWidget</code> A base widget with no value. <code>FileEdit</code> A LineEdit widget with a button that opens a FileDialog. <code>FloatRangeSlider</code> A slider widget to adjust a range defined by two float values within a range. <code>FloatSlider</code> A slider widget to adjust an integer value within a range. <code>FloatSpinBox</code> A widget to edit a float with clickable up/down arrows. <code>FunctionGui</code> Wrapper for a container of widgets representing a callable object. <code>Image</code> A non-editable image display. <code>Label</code> A non-editable text display. <code>LineEdit</code> A one-line text editor. <code>ListEdit</code> A widget to represent a list of values. <code>LiteralEvalLineEdit</code> A one-line text editor that evaluates strings as python literals. <code>LogSlider</code> A slider widget to adjust a numerical value logarithmically within a range. <code>MainFunctionGui</code> Container of widgets as a Main Application Window. <code>MainWindow</code> A Widget to contain other widgets, includes a menu bar. <code>Password</code> A one-line text editor that obscures input. <code>ProgressBar</code> A progress bar widget. <code>PushButton</code> A clickable command button. <code>QuantityEdit</code> A combined <code>LineEdit</code> and <code>ComboBox</code> to edit a <code>pint.Quantity</code>. <code>RadioButton</code> A radio button with a text label. <code>RadioButtons</code> An exclusive group of radio buttons, providing a choice from multiple choices. <code>RangeEdit</code> A widget to represent a python range object, with start/stop/step. <code>RangeSlider</code> A slider widget to adjust a range between two integer values within a range. <code>Select</code> A list of options, allowing selection between multiple choices. <code>SliceEdit</code> A widget to represent <code>slice</code> objects, with start/stop/step. <code>Slider</code> A slider widget to adjust an integer value within a range. <code>SpinBox</code> A widget to edit an integer with clickable up/down arrows. <code>Table</code> A widget to represent columnar or 2D data with headers. <code>TextEdit</code> A widget to edit and display both plain and rich text. <code>TimeEdit</code> A widget for editing times. <code>ToolBar</code> Toolbar that contains a set of controls. <code>TupleEdit</code> A widget to represent a tuple of values."},{"location":"api/widgets/CheckBox/","title":"CheckBox","text":"<p>Available in backends: <code>qt</code>, <code>ipynb</code></p>"},{"location":"api/widgets/CheckBox/#signals","title":"Signals","text":"<ul> <li><code>changed(object)</code> - Emitted when the button is clicked (may also be connected at the alias <code>clicked</code>).</li> <li><code>label_changed(str)</code> - Emitted when the widget label changes.</li> <li><code>parent_changed(object)</code> - Emitted with the backend widget when the widget parent changes.</li> </ul>"},{"location":"api/widgets/CheckBox/#magicgui.widgets.CheckBox","title":"<code>CheckBox</code>","text":"<p>             Bases: <code>ButtonWidget</code></p> <p>A checkbox with a text label.</p> <p>Parameters:</p> <ul> <li> value             (<code>bool</code>, default:                 <code>Undefined</code> )         \u2013          <p>The starting state of the widget.</p> </li> <li> text             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>The text to display on the button. If not provided, will use <code>name</code>.</p> </li> <li> bind             (<code>Callable[[ValueWidget], Any] | Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>A value or callback to bind this widget. If provided, whenever <code>widget.value</code> is accessed, the value provided here will be returned instead. <code>bind</code> may be a callable, in which case <code>bind(self)</code> will be returned (i.e. your bound callback must accept a single parameter, which is this widget instance).</p> </li> <li> nullable             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, the widget will accepts <code>None</code> as a valid value, by default <code>False</code>.</p> </li> <li> **base_widget_kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>All additional keyword arguments are passed to the base <code>magicgui.widgets.Widget</code> constructor.</p> </li> </ul>"},{"location":"api/widgets/ComboBox/","title":"ComboBox","text":"<p>Available in backends: <code>qt</code>, <code>ipynb</code></p>"},{"location":"api/widgets/ComboBox/#signals","title":"Signals","text":"<ul> <li><code>changed(object)</code> - Emitted when the widget value changes.</li> <li><code>label_changed(str)</code> - Emitted when the widget label changes.</li> <li><code>parent_changed(object)</code> - Emitted with the backend widget when the widget parent changes.</li> </ul>"},{"location":"api/widgets/ComboBox/#magicgui.widgets.ComboBox","title":"<code>ComboBox</code>","text":"<p>             Bases: <code>CategoricalWidget</code></p> <p>A dropdown menu, allowing selection between multiple choices.</p> <p>Parameters:</p> <ul> <li> value             (<code>Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>The initially selected choice.</p> </li> <li> choices             (<code>Enum, Iterable, or Callable</code>, default:                 <code>()</code> )         \u2013          <p>Available choices displayed in the combo box.</p> </li> <li> bind             (<code>Callable[[ValueWidget], Any] | Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>A value or callback to bind this widget. If provided, whenever <code>widget.value</code> is accessed, the value provided here will be returned instead. <code>bind</code> may be a callable, in which case <code>bind(self)</code> will be returned (i.e. your bound callback must accept a single parameter, which is this widget instance).</p> </li> <li> nullable             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, the widget will accepts <code>None</code> as a valid value, by default <code>False</code>.</p> </li> <li> **base_widget_kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>All additional keyword arguments are passed to the base <code>magicgui.widgets.Widget</code> constructor.</p> </li> </ul>"},{"location":"api/widgets/Container/","title":"Container","text":"<p>Available in backends: <code>qt</code>, <code>ipynb</code></p>"},{"location":"api/widgets/Container/#signals","title":"Signals","text":"<ul> <li><code>changed(object)</code> - Emitted with <code>self</code> when any sub-widget in the container changes.</li> <li><code>label_changed(str)</code> - Emitted when the widget label changes.</li> <li><code>parent_changed(object)</code> - Emitted with the backend widget when the widget parent changes.</li> </ul>"},{"location":"api/widgets/Container/#magicgui.widgets.Container","title":"<code>Container</code>","text":"<p>             Bases: <code>ContainerWidget[WidgetVar]</code></p> <p>A Widget to contain other widgets.</p> <pre><code>Note that `Container` implements the\n[`typing.MutableSequence`][typing.MutableSequence]\ninterface, so you can use it like a list to add and remove widgets.\n</code></pre> <p>Parameters:</p> <ul> <li> widgets             (<code>Sequence[Widget]</code>, default:                 <code>()</code> )         \u2013          <p>A sequence of widgets with which to initialize the container, by default <code>None</code>.</p> </li> <li> layout             (<code>str</code>, default:                 <code>'vertical'</code> )         \u2013          <p>The layout for the container.  must be one of <code>{'horizontal', 'vertical'}</code>. by default \"vertical\"</p> </li> <li> scrollable             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to enable scroll bars or not. If enabled, scroll bars will only appear along the layout direction, not in both directions.</p> </li> <li> labels             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether each widget should be shown with a corresponding Label widget to the left, by default <code>True</code>.  Note: the text for each widget defaults to <code>widget.name</code>, but can be overridden by setting <code>widget.label</code>.</p> </li> <li> **base_widget_kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>All additional keyword arguments are passed to the base <code>magicgui.widgets.Widget</code> constructor.</p> </li> </ul>"},{"location":"api/widgets/DateEdit/","title":"DateEdit","text":"<p>Available in backends: <code>qt</code>, <code>ipynb</code></p>"},{"location":"api/widgets/DateEdit/#signals","title":"Signals","text":"<ul> <li><code>changed(object)</code> - Emitted when the widget value changes.</li> <li><code>label_changed(str)</code> - Emitted when the widget label changes.</li> <li><code>parent_changed(object)</code> - Emitted with the backend widget when the widget parent changes.</li> </ul>"},{"location":"api/widgets/DateEdit/#magicgui.widgets.DateEdit","title":"<code>DateEdit</code>","text":"<p>             Bases: <code>ValueWidget[date]</code></p> <p>A widget for editing dates.</p> <p>Parameters:</p> <ul> <li> value             (<code>Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>The starting value for the widget.</p> </li> <li> bind             (<code>Callable[[ValueWidget], Any] | Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>A value or callback to bind this widget. If provided, whenever <code>widget.value</code> is accessed, the value provided here will be returned instead. <code>bind</code> may be a callable, in which case <code>bind(self)</code> will be returned (i.e. your bound callback must accept a single parameter, which is this widget instance).</p> </li> <li> nullable             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, the widget will accepts <code>None</code> as a valid value, by default <code>False</code>.</p> </li> <li> **base_widget_kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>All additional keyword arguments are passed to the base <code>magicgui.widgets.Widget</code> constructor.</p> </li> </ul>"},{"location":"api/widgets/DateTimeEdit/","title":"DateTimeEdit","text":"<p>Available in backends: <code>qt</code>, <code>ipynb</code></p>"},{"location":"api/widgets/DateTimeEdit/#signals","title":"Signals","text":"<ul> <li><code>changed(object)</code> - Emitted when the widget value changes.</li> <li><code>label_changed(str)</code> - Emitted when the widget label changes.</li> <li><code>parent_changed(object)</code> - Emitted with the backend widget when the widget parent changes.</li> </ul>"},{"location":"api/widgets/DateTimeEdit/#magicgui.widgets.DateTimeEdit","title":"<code>DateTimeEdit</code>","text":"<p>             Bases: <code>ValueWidget[datetime]</code></p> <p>A widget for editing dates and times.</p> <p>Parameters:</p> <ul> <li> value             (<code>Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>The starting value for the widget.</p> </li> <li> bind             (<code>Callable[[ValueWidget], Any] | Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>A value or callback to bind this widget. If provided, whenever <code>widget.value</code> is accessed, the value provided here will be returned instead. <code>bind</code> may be a callable, in which case <code>bind(self)</code> will be returned (i.e. your bound callback must accept a single parameter, which is this widget instance).</p> </li> <li> nullable             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, the widget will accepts <code>None</code> as a valid value, by default <code>False</code>.</p> </li> <li> **base_widget_kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>All additional keyword arguments are passed to the base <code>magicgui.widgets.Widget</code> constructor.</p> </li> </ul>"},{"location":"api/widgets/Dialog/","title":"Dialog","text":"<p>Available in backends: <code>qt</code></p>"},{"location":"api/widgets/Dialog/#signals","title":"Signals","text":"<ul> <li><code>changed(object)</code> - Emitted with <code>self</code> when any sub-widget in the container changes.</li> <li><code>label_changed(str)</code> - Emitted when the widget label changes.</li> <li><code>parent_changed(object)</code> - Emitted with the backend widget when the widget parent changes.</li> </ul>"},{"location":"api/widgets/Dialog/#magicgui.widgets.Dialog","title":"<code>Dialog</code>","text":"<p>             Bases: <code>DialogWidget</code></p> <p>A modal container.</p> <p>Parameters:</p> <ul> <li> widgets             (<code>Sequence[Widget]</code>, default:                 <code>()</code> )         \u2013          <p>A sequence of widgets with which to initialize the container, by default <code>None</code>.</p> </li> <li> layout             (<code>str</code>, default:                 <code>'vertical'</code> )         \u2013          <p>The layout for the container.  must be one of <code>{'horizontal', 'vertical'}</code>. by default \"vertical\"</p> </li> <li> scrollable             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to enable scroll bars or not. If enabled, scroll bars will only appear along the layout direction, not in both directions.</p> </li> <li> labels             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether each widget should be shown with a corresponding Label widget to the left, by default <code>True</code>.  Note: the text for each widget defaults to <code>widget.name</code>, but can be overridden by setting <code>widget.label</code>.</p> </li> <li> **base_widget_kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>All additional keyword arguments are passed to the base <code>magicgui.widgets.Widget</code> constructor.</p> </li> </ul>"},{"location":"api/widgets/EmptyWidget/","title":"EmptyWidget","text":"<p>Available in backends: <code>qt</code>, <code>ipynb</code></p>"},{"location":"api/widgets/EmptyWidget/#signals","title":"Signals","text":"<ul> <li><code>changed(object)</code> - Emitted when the widget value changes.</li> <li><code>label_changed(str)</code> - Emitted when the widget label changes.</li> <li><code>parent_changed(object)</code> - Emitted with the backend widget when the widget parent changes.</li> </ul>"},{"location":"api/widgets/EmptyWidget/#magicgui.widgets.EmptyWidget","title":"<code>EmptyWidget</code>","text":"<p>             Bases: <code>ValueWidget</code></p> <p>A base widget with no value.</p> <pre><code>This widget is primarily here to serve as a \"hidden widget\" to which a value or\ncallback can be bound.\n</code></pre> <p>Parameters:</p> <ul> <li> value             (<code>Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>The starting value for the widget.</p> </li> <li> bind             (<code>Callable[[ValueWidget], Any] | Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>A value or callback to bind this widget. If provided, whenever <code>widget.value</code> is accessed, the value provided here will be returned instead. <code>bind</code> may be a callable, in which case <code>bind(self)</code> will be returned (i.e. your bound callback must accept a single parameter, which is this widget instance).</p> </li> <li> nullable             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, the widget will accepts <code>None</code> as a valid value, by default <code>False</code>.</p> </li> <li> **base_widget_kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>All additional keyword arguments are passed to the base <code>magicgui.widgets.Widget</code> constructor.</p> </li> </ul>"},{"location":"api/widgets/EmptyWidget/#magicgui.widgets.EmptyWidget.value","title":"<code>value: Any</code>  <code>property</code> <code>writable</code>","text":"<p>Look for a bound value, otherwise fallback to <code>get_value</code>.</p>"},{"location":"api/widgets/EmptyWidget/#magicgui.widgets.EmptyWidget.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Return string repr (avoid looking for value).</p>"},{"location":"api/widgets/EmptyWidget/#magicgui.widgets.EmptyWidget.get_value","title":"<code>get_value() -&gt; Any</code>","text":"<p>Return value if one has been manually set... otherwise return Param.empty.</p>"},{"location":"api/widgets/FileEdit/","title":"FileEdit","text":"<p>Available in backends: </p>"},{"location":"api/widgets/FileEdit/#signals","title":"Signals","text":"<ul> <li><code>changed(object)</code> - Emitted with <code>self</code> when any sub-widget in the container changes.</li> <li><code>label_changed(str)</code> - Emitted when the widget label changes.</li> <li><code>parent_changed(object)</code> - Emitted with the backend widget when the widget parent changes.</li> </ul>"},{"location":"api/widgets/FileEdit/#magicgui.widgets.FileEdit","title":"<code>FileEdit</code>","text":"<p>             Bases: <code>Container</code></p> <p>A LineEdit widget with a button that opens a FileDialog.</p> <p>Parameters:</p> <ul> <li> mode             (<code>FileDialogMode or str</code>, default:                 <code>EXISTING_FILE</code> )         \u2013          <ul> <li><code>'r'</code> returns one existing file.</li> <li><code>'rm'</code> return one or more existing files.</li> <li><code>'w'</code> return one file name that does not have to exist.</li> <li><code>'d'</code> returns one existing directory.</li> </ul> </li> <li> filter             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>The filter is used to specify the kind of files that should be shown. It should be a glob-style string, like <code>'*.png'</code> (this may be backend-specific)</p> </li> </ul>"},{"location":"api/widgets/FileEdit/#magicgui.widgets.FileEdit.mode","title":"<code>mode: FileDialogMode</code>  <code>property</code> <code>writable</code>","text":"<p>Mode for the FileDialog.</p>"},{"location":"api/widgets/FileEdit/#magicgui.widgets.FileEdit.value","title":"<code>value: tuple[Path, ...] | Path | None</code>  <code>property</code> <code>writable</code>","text":"<p>Return current value of the widget.  This may be interpreted by backends.</p>"},{"location":"api/widgets/FileEdit/#magicgui.widgets.FileEdit.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Return string representation.</p>"},{"location":"api/widgets/FloatRangeSlider/","title":"FloatRangeSlider","text":"<p>Available in backends: <code>qt</code></p>"},{"location":"api/widgets/FloatRangeSlider/#signals","title":"Signals","text":"<ul> <li><code>changed(object)</code> - Emitted when the widget value changes.</li> <li><code>label_changed(str)</code> - Emitted when the widget label changes.</li> <li><code>parent_changed(object)</code> - Emitted with the backend widget when the widget parent changes.</li> </ul>"},{"location":"api/widgets/FloatRangeSlider/#magicgui.widgets.FloatRangeSlider","title":"<code>FloatRangeSlider</code>","text":"<p>             Bases: <code>MultiValuedSliderWidget</code></p> <p>A slider widget to adjust a range defined by two float values within a range.</p> <p>Parameters:</p> <ul> <li> value             (<code>Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>The starting value for the widget.</p> </li> <li> min             (<code>float</code>, default:                 <code>Undefined</code> )         \u2013          <p>The minimum allowable value, by default 0 (or <code>value</code> if <code>value</code> is less than 0)</p> </li> <li> max             (<code>float</code>, default:                 <code>Undefined</code> )         \u2013          <p>The maximum allowable value, by default 999 (or <code>value</code> if <code>value</code> is greater than 999)</p> </li> <li> step             (<code>float</code>, default:                 <code>Undefined</code> )         \u2013          <p>The step size for incrementing the value, by default adaptive step is used</p> </li> <li> orientation             (<code>(str, {'horizontal', 'vertical'})</code>, default:                 <code>'horizontal'</code> )         \u2013          <p>The orientation for the slider, by default \"horizontal\"</p> </li> <li> readout             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to show the editable spinbox next to the slider</p> </li> <li> tracking             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>If tracking is enabled (the default), the slider emits the <code>changed</code> signal while the slider is being dragged. If tracking is disabled, the slider emits the <code>changed</code> signal only after the user releases the slider.</p> </li> <li> bind             (<code>Callable[[ValueWidget], Any] | Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>A value or callback to bind this widget. If provided, whenever <code>widget.value</code> is accessed, the value provided here will be returned instead. <code>bind</code> may be a callable, in which case <code>bind(self)</code> will be returned (i.e. your bound callback must accept a single parameter, which is this widget instance).</p> </li> <li> nullable             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, the widget will accepts <code>None</code> as a valid value, by default <code>False</code>.</p> </li> <li> **base_widget_kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>All additional keyword arguments are passed to the base <code>magicgui.widgets.Widget</code> constructor.</p> </li> </ul>"},{"location":"api/widgets/FloatSlider/","title":"FloatSlider","text":"<p>Available in backends: <code>qt</code>, <code>ipynb</code></p>"},{"location":"api/widgets/FloatSlider/#signals","title":"Signals","text":"<ul> <li><code>changed(object)</code> - Emitted when the widget value changes.</li> <li><code>label_changed(str)</code> - Emitted when the widget label changes.</li> <li><code>parent_changed(object)</code> - Emitted with the backend widget when the widget parent changes.</li> </ul>"},{"location":"api/widgets/FloatSlider/#magicgui.widgets.FloatSlider","title":"<code>FloatSlider</code>","text":"<p>             Bases: <code>SliderWidget[float]</code></p> <p>A slider widget to adjust an integer value within a range.</p> <p>Parameters:</p> <ul> <li> value             (<code>Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>The starting value for the widget.</p> </li> <li> min             (<code>float</code>, default:                 <code>Undefined</code> )         \u2013          <p>The minimum allowable value, by default 0 (or <code>value</code> if <code>value</code> is less than 0)</p> </li> <li> max             (<code>float</code>, default:                 <code>Undefined</code> )         \u2013          <p>The maximum allowable value, by default 999 (or <code>value</code> if <code>value</code> is greater than 999)</p> </li> <li> step             (<code>float</code>, default:                 <code>Undefined</code> )         \u2013          <p>The step size for incrementing the value, by default adaptive step is used</p> </li> <li> orientation             (<code>(str, {'horizontal', 'vertical'})</code>, default:                 <code>'horizontal'</code> )         \u2013          <p>The orientation for the slider, by default \"horizontal\"</p> </li> <li> readout             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to show the editable spinbox next to the slider</p> </li> <li> tracking             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>If tracking is enabled (the default), the slider emits the <code>changed</code> signal while the slider is being dragged. If tracking is disabled, the slider emits the <code>changed</code> signal only after the user releases the slider.</p> </li> <li> bind             (<code>Callable[[ValueWidget], Any] | Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>A value or callback to bind this widget. If provided, whenever <code>widget.value</code> is accessed, the value provided here will be returned instead. <code>bind</code> may be a callable, in which case <code>bind(self)</code> will be returned (i.e. your bound callback must accept a single parameter, which is this widget instance).</p> </li> <li> nullable             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, the widget will accepts <code>None</code> as a valid value, by default <code>False</code>.</p> </li> <li> **base_widget_kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>All additional keyword arguments are passed to the base <code>magicgui.widgets.Widget</code> constructor.</p> </li> </ul>"},{"location":"api/widgets/FloatSpinBox/","title":"FloatSpinBox","text":"<p>Available in backends: <code>qt</code>, <code>ipynb</code></p>"},{"location":"api/widgets/FloatSpinBox/#signals","title":"Signals","text":"<ul> <li><code>changed(object)</code> - Emitted when the widget value changes.</li> <li><code>label_changed(str)</code> - Emitted when the widget label changes.</li> <li><code>parent_changed(object)</code> - Emitted with the backend widget when the widget parent changes.</li> </ul>"},{"location":"api/widgets/FloatSpinBox/#magicgui.widgets.FloatSpinBox","title":"<code>FloatSpinBox</code>","text":"<p>             Bases: <code>RangedWidget[float]</code></p> <p>A widget to edit a float with clickable up/down arrows.</p> <p>Parameters:</p> <ul> <li> value             (<code>Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>The starting value for the widget.</p> </li> <li> min             (<code>float</code>, default:                 <code>Undefined</code> )         \u2013          <p>The minimum allowable value, by default 0 (or <code>value</code> if <code>value</code> is less than 0)</p> </li> <li> max             (<code>float</code>, default:                 <code>Undefined</code> )         \u2013          <p>The maximum allowable value, by default 999 (or <code>value</code> if <code>value</code> is greater than 999)</p> </li> <li> step             (<code>float</code>, default:                 <code>Undefined</code> )         \u2013          <p>The step size for incrementing the value, by default adaptive step is used</p> </li> <li> bind             (<code>Callable[[ValueWidget], Any] | Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>A value or callback to bind this widget. If provided, whenever <code>widget.value</code> is accessed, the value provided here will be returned instead. <code>bind</code> may be a callable, in which case <code>bind(self)</code> will be returned (i.e. your bound callback must accept a single parameter, which is this widget instance).</p> </li> <li> nullable             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, the widget will accepts <code>None</code> as a valid value, by default <code>False</code>.</p> </li> <li> **base_widget_kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>All additional keyword arguments are passed to the base <code>magicgui.widgets.Widget</code> constructor.</p> </li> </ul>"},{"location":"api/widgets/FunctionGui/","title":"FunctionGui","text":"<p>Available in backends: </p>"},{"location":"api/widgets/FunctionGui/#signals","title":"Signals","text":"<ul> <li><code>called(object)</code> - Emitted with the result after the function is called.</li> <li><code>changed(object)</code> - Emitted with <code>self</code> when any sub-widget in the container changes.</li> <li><code>label_changed(str)</code> - Emitted when the widget label changes.</li> <li><code>parent_changed(object)</code> - Emitted with the backend widget when the widget parent changes.</li> </ul>"},{"location":"api/widgets/FunctionGui/#magicgui.widgets.FunctionGui","title":"<code>FunctionGui</code>","text":"<p>             Bases: <code>Container</code>, <code>Generic[_P, _R]</code></p> <p>Wrapper for a container of widgets representing a callable object.</p> <p>Parameters:</p> <ul> <li> function             (<code>Callable</code>)         \u2013          <p>A callable to turn into a GUI</p> </li> <li> call_button             (<code>bool | str | None</code>, default:                 <code>None</code> )         \u2013          <p>If True, create an additional button that calls the original function when clicked.  If a <code>str</code>, set the button text. by default False when auto_call is True, and True otherwise. The button can be accessed from the <code>.call_button</code> property.</p> </li> <li> layout             (<code>str</code>, default:                 <code>'vertical'</code> )         \u2013          <p>The type of layout to use. Must be <code>horizontal</code> or <code>vertical</code> by default \"horizontal\".</p> </li> <li> scrollable             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to enable scroll bars or not. If enabled, scroll bars will only appear along the layout direction, not in both directions.</p> </li> <li> labels             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether labels are shown in the widget. by default True</p> </li> <li> tooltips             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether tooltips are shown when hovering over widgets. by default True</p> </li> <li> app             (<code>Application | str | None</code>, default:                 <code>None</code> )         \u2013          <p>A backend to use, by default <code>None</code> (use the default backend.)</p> </li> <li> visible             (<code>bool</code>, default:                 <code>None</code> )         \u2013          <p>Whether to immediately show the widget.  If <code>False</code>, widget is explicitly hidden.  If <code>None</code>, widget is not shown, but will be shown if a parent container is shown, by default None.</p> </li> <li> auto_call             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If True, changing any parameter in either the GUI or the widget attributes will call the original function with the current settings. by default False</p> </li> <li> result_widget             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to display a LineEdit widget the output of the function when called, by default False</p> </li> <li> param_options             (<code>dict</code>, default:                 <code>None</code> )         \u2013          <p>A dict of name: widget_options dict for each parameter in the function. Will be passed to <code>magic_signature</code> by default <code>None</code></p> </li> <li> name             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>A name to assign to the Container widget, by default <code>function.__name__</code></p> </li> <li> persist             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, when parameter values change in the widget, they will be stored to disk (in <code>~/.config/magicgui/cache</code>) and restored when the widget is loaded again with <code>persist = True</code>.  By default, <code>False</code>.</p> </li> <li> raise_on_unknown             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If True, raise an error if a parameter annotation is not recognized.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>           \u2013          <p>If unexpected keyword arguments are provided</p> </li> </ul>"},{"location":"api/widgets/FunctionGui/#magicgui.widgets.FunctionGui.__signature__","title":"<code>__signature__: MagicSignature</code>  <code>property</code>","text":"<p>Return a MagicSignature object representing the current state of the gui.</p>"},{"location":"api/widgets/FunctionGui/#magicgui.widgets.FunctionGui.call_button","title":"<code>call_button: PushButton | None</code>  <code>property</code>","text":"<p>Return the call button.</p>"},{"location":"api/widgets/FunctionGui/#magicgui.widgets.FunctionGui.call_count","title":"<code>call_count: int</code>  <code>property</code>","text":"<p>Return the number of times the function has been called.</p>"},{"location":"api/widgets/FunctionGui/#magicgui.widgets.FunctionGui.result_name","title":"<code>result_name: str</code>  <code>property</code> <code>writable</code>","text":"<p>Return a name that can be used for the result of this magicfunction.</p>"},{"location":"api/widgets/FunctionGui/#magicgui.widgets.FunctionGui.return_annotation","title":"<code>return_annotation: Any</code>  <code>property</code>","text":"<p>Return annotation for inspect.Signature conversion.</p> <p>ForwardRefs will be resolve when setting the annotation.</p>"},{"location":"api/widgets/FunctionGui/#magicgui.widgets.FunctionGui.__call__","title":"<code>__call__(*args: _P.args, **kwargs: _P.kwargs) -&gt; _R</code>","text":"<p>Call the original function with the current parameter values from the Gui.</p> <p>You may pass a <code>update_widget=True</code> keyword argument to update the widget values to match the current parameter values before calling the function.</p> <p>It is also possible to override the current parameter values from the GUI by providing args/kwargs to the function call.  Only those provided will override the ones from the gui.  A <code>called</code> signal will also be emitted with the results.</p> <p>Returns:</p> <ul> <li> result (            <code>Any</code> )        \u2013          <p>whatever the return value of the original function would have been.</p> </li> </ul> <p>Examples:</p> <pre><code>gui = FunctionGui(func, show=True)\n\n# then change parameters in the gui, or by setting:  gui.param.value = something\n\ngui()  # calls the original function with the current parameters\n</code></pre>"},{"location":"api/widgets/FunctionGui/#magicgui.widgets.FunctionGui.__get__","title":"<code>__get__(obj: object, objtype: type | None = None) -&gt; FunctionGui</code>","text":"<p>Provide descriptor protocol.</p> <p>This allows the @magicgui decorator to work on a function as well as a method. If a method on a class is decorated with <code>@magicgui</code>, then accessing the attribute on an instance of that class will return a version of the FunctionGui in which the first argument of the function is bound to the instance. (Just like what you'd expect with the @property decorator.)</p> <p>Returns:</p> <ul> <li> bound (            <code>FunctionGui</code> )        \u2013          <p>A new FunctionGui instance.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class MyClass:\n...     @magicgui\n...     def my_method(self, x=1):\n...         print(locals())\n...\n&gt;&gt;&gt; c = MyClass()\n&gt;&gt;&gt; c.my_method  # the FunctionGui that can be used as a widget\n\n# calling it works as usual, with `c` provided as `self`\n&gt;&gt;&gt; c.my_method(x=34)\n{'self': &lt;__main__.MyClass object at 0x7fb610e455e0&gt;, 'x': 34}\n</code></pre>"},{"location":"api/widgets/FunctionGui/#magicgui.widgets.FunctionGui.__init__","title":"<code>__init__(function: Callable[_P, _R], call_button: bool | str | None = None, layout: str = 'vertical', scrollable: bool = False, labels: bool = True, tooltips: bool = True, app: AppRef | None = None, visible: bool | None = None, auto_call: bool = False, result_widget: bool = False, param_options: dict[str, dict] | None = None, name: str | None = None, persist: bool = False, raise_on_unknown: bool = False, **kwargs: Any)</code>","text":""},{"location":"api/widgets/FunctionGui/#magicgui.widgets.FunctionGui.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Return string representation of instance.</p>"},{"location":"api/widgets/FunctionGui/#magicgui.widgets.FunctionGui.__set__","title":"<code>__set__(obj: Any, value: Any) -&gt; NoReturn</code>","text":"<p>Prevent setting a magicgui attribute.</p>"},{"location":"api/widgets/FunctionGui/#magicgui.widgets.FunctionGui.copy","title":"<code>copy() -&gt; FunctionGui</code>","text":"<p>Return a copy of this FunctionGui.</p>"},{"location":"api/widgets/FunctionGui/#magicgui.widgets.FunctionGui.reset_call_count","title":"<code>reset_call_count() -&gt; None</code>","text":"<p>Reset the call count to 0.</p>"},{"location":"api/widgets/Image/","title":"Image","text":"<p>Available in backends: <code>qt</code></p>"},{"location":"api/widgets/Image/#signals","title":"Signals","text":"<ul> <li><code>changed(object)</code> - Emitted when the widget value changes.</li> <li><code>label_changed(str)</code> - Emitted when the widget label changes.</li> <li><code>parent_changed(object)</code> - Emitted with the backend widget when the widget parent changes.</li> </ul>"},{"location":"api/widgets/Image/#magicgui.widgets.Image","title":"<code>Image</code>","text":"<p>             Bases: <code>ValueWidget</code></p> <p>A non-editable image display.</p> <p>Parameters:</p> <ul> <li> value             (<code>Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>The starting value for the widget.</p> </li> <li> bind             (<code>Callable[[ValueWidget], Any] | Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>A value or callback to bind this widget. If provided, whenever <code>widget.value</code> is accessed, the value provided here will be returned instead. <code>bind</code> may be a callable, in which case <code>bind(self)</code> will be returned (i.e. your bound callback must accept a single parameter, which is this widget instance).</p> </li> <li> nullable             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, the widget will accepts <code>None</code> as a valid value, by default <code>False</code>.</p> </li> <li> **base_widget_kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>All additional keyword arguments are passed to the base <code>magicgui.widgets.Widget</code> constructor.</p> </li> </ul>"},{"location":"api/widgets/Image/#magicgui.widgets.Image.image_data","title":"<code>image_data: np.ndarray | None</code>  <code>property</code>","text":"<p>Return image data.</p>"},{"location":"api/widgets/Image/#magicgui.widgets.Image.image_rgba","title":"<code>image_rgba: np.ndarray | None</code>  <code>property</code>","text":"<p>Return rendered numpy array.</p>"},{"location":"api/widgets/Image/#magicgui.widgets.Image.value","title":"<code>value</code>  <code>property</code> <code>writable</code>","text":"<p>Return current image array.</p>"},{"location":"api/widgets/Image/#magicgui.widgets.Image.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Return representation of widget of instance.</p>"},{"location":"api/widgets/Image/#magicgui.widgets.Image.get_clim","title":"<code>get_clim() -&gt; tuple[float | None, float | None]</code>","text":"<p>Get contrast limits (for monochromatic images).</p>"},{"location":"api/widgets/Image/#magicgui.widgets.Image.scale_widget_to_image_size","title":"<code>scale_widget_to_image_size()</code>","text":"<p>Set the size of the widget to the size of the image.</p>"},{"location":"api/widgets/Image/#magicgui.widgets.Image.set_clim","title":"<code>set_clim(vmin: float | None = None, vmax: float | None = None)</code>","text":"<p>Set contrast limits (for monochromatic images).</p> <p>Parameters:</p> <ul> <li> vmin             (<code>float</code>, default:                 <code>None</code> )         \u2013          <p>The min contrast limit to use when scaling monochromatic images</p> </li> <li> vmax             (<code>float</code>, default:                 <code>None</code> )         \u2013          <p>The max contrast limit to use when scaling monochromatic images</p> </li> </ul>"},{"location":"api/widgets/Image/#magicgui.widgets.Image.set_cmap","title":"<code>set_cmap(cmap: str | Colormap | matplotlib.colors.Colormap)</code>","text":"<p>Set colormap (for monochromatic images).</p> <p>Parameters:</p> <ul> <li> cmap             (<code>str, magicgui.types.Colormap, or matplotlib.colors.Colormap</code>)         \u2013          <p>A colormap to use for monochromatic images.  If a string, matplotlib must be installed and the colormap will be selected with <code>cm.get_cmap(cmap)</code>.</p> </li> </ul>"},{"location":"api/widgets/Image/#magicgui.widgets.Image.set_data","title":"<code>set_data(val: str | Path | np.ndarray | PIL.Image.Image, cmap: str | Colormap | matplotlib.colors.Colormap | None = None, norm: _mpl_image.Normalize | matplotlib.colors.Normalize | None = None, vmin: float | None = None, vmax: float | None = None, width: int | Literal['auto'] | None = None, height: int | Literal['auto'] | None = None, format: str | None = None)</code>","text":"<p>Set image data with various optional display parameters.</p> <p>Parameters:</p> <ul> <li> val             (<code>(str, Path, ndarray or Image)</code>)         \u2013          <p>The image data or file to load. Data must be 2D (monochromatic), or 3D: MxNx3 (RGB) or MxNx4 (RGBA).</p> </li> <li> cmap             (<code>str, magicgui.types.Colormap, or matplotlib.colors.Colormap</code>, default:                 <code>None</code> )         \u2013          <p>A colormap to use for monochromatic images.  If a string, matplotlib must be installed and the colormap will be selected with <code>cm.get_cmap(cmap)</code>.</p> </li> <li> norm             (<code>magicgui.types.Normalize, or matplotlib.colors.Normalize</code>, default:                 <code>None</code> )         \u2013          <p>A normalization object to use for rendering images.  Accepts matplotlib Normalize objects.</p> </li> <li> vmin             (<code>float</code>, default:                 <code>None</code> )         \u2013          <p>The min contrast limit to use when scaling monochromatic images</p> </li> <li> vmax             (<code>float</code>, default:                 <code>None</code> )         \u2013          <p>The max contrast limit to use when scaling monochromatic images</p> </li> <li> width             (<code>int or 'auto'</code>, default:                 <code>None</code> )         \u2013          <p>Set the width of the widget. If \"auto\", sets the widget size to the image size (1:1). If width is provided, height is auto-set based on aspect ratio.</p> </li> <li> height             (<code>int or 'auto'</code>, default:                 <code>None</code> )         \u2013          <p>Set the height of the widget. If \"auto\", sets the widget size to the image size (1:1).  If width is provided, height is auto-set based on aspect ratio.</p> </li> <li> format             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>Force image format type for <code>imread</code> when <code>val</code> is provided as a string, by default None</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>           \u2013          <p>If the provided data shape or type is invalid.</p> </li> <li> <code>ImportError</code>           \u2013          <p>If a string is provided for <code>val</code> and PIL is not installed.</p> </li> <li> <code>RuntimeError</code>           \u2013          <p>If a <code>PIL.Image.Image</code> instance is provided as data, with an unrecognized image mode.</p> </li> </ul>"},{"location":"api/widgets/Image/#magicgui.widgets.Image.set_norm","title":"<code>set_norm(norm: Normalize | matplotlib.colors.Normalize)</code>","text":"<p>Set normalization method.</p> <p>Parameters:</p> <ul> <li> norm             (<code>magicgui.types.Normalize, or matplotlib.colors.Normalize</code>)         \u2013          <p>A normalization object to use for rendering images.  Accepts matplotlib Normalize objects.</p> </li> </ul>"},{"location":"api/widgets/Label/","title":"Label","text":"<p>Available in backends: <code>qt</code>, <code>ipynb</code></p>"},{"location":"api/widgets/Label/#signals","title":"Signals","text":"<ul> <li><code>changed(object)</code> - Emitted when the widget value changes.</li> <li><code>label_changed(str)</code> - Emitted when the widget label changes.</li> <li><code>parent_changed(object)</code> - Emitted with the backend widget when the widget parent changes.</li> </ul>"},{"location":"api/widgets/Label/#magicgui.widgets.Label","title":"<code>Label</code>","text":"<p>             Bases: <code>ValueWidget[str]</code></p> <p>A non-editable text display.</p> <p>Parameters:</p> <ul> <li> value             (<code>Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>The starting value for the widget.</p> </li> <li> bind             (<code>Callable[[ValueWidget], Any] | Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>A value or callback to bind this widget. If provided, whenever <code>widget.value</code> is accessed, the value provided here will be returned instead. <code>bind</code> may be a callable, in which case <code>bind(self)</code> will be returned (i.e. your bound callback must accept a single parameter, which is this widget instance).</p> </li> <li> nullable             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, the widget will accepts <code>None</code> as a valid value, by default <code>False</code>.</p> </li> <li> **base_widget_kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>All additional keyword arguments are passed to the base <code>magicgui.widgets.Widget</code> constructor.</p> </li> </ul>"},{"location":"api/widgets/LineEdit/","title":"LineEdit","text":"<p>Available in backends: <code>qt</code>, <code>ipynb</code></p>"},{"location":"api/widgets/LineEdit/#signals","title":"Signals","text":"<ul> <li><code>changed(object)</code> - Emitted when the widget value changes.</li> <li><code>label_changed(str)</code> - Emitted when the widget label changes.</li> <li><code>parent_changed(object)</code> - Emitted with the backend widget when the widget parent changes.</li> </ul>"},{"location":"api/widgets/LineEdit/#magicgui.widgets.LineEdit","title":"<code>LineEdit</code>","text":"<p>             Bases: <code>ValueWidget[str]</code></p> <p>A one-line text editor.</p> <p>Parameters:</p> <ul> <li> value             (<code>Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>The starting value for the widget.</p> </li> <li> bind             (<code>Callable[[ValueWidget], Any] | Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>A value or callback to bind this widget. If provided, whenever <code>widget.value</code> is accessed, the value provided here will be returned instead. <code>bind</code> may be a callable, in which case <code>bind(self)</code> will be returned (i.e. your bound callback must accept a single parameter, which is this widget instance).</p> </li> <li> nullable             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, the widget will accepts <code>None</code> as a valid value, by default <code>False</code>.</p> </li> <li> **base_widget_kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>All additional keyword arguments are passed to the base <code>magicgui.widgets.Widget</code> constructor.</p> </li> </ul>"},{"location":"api/widgets/ListEdit/","title":"ListEdit","text":"<p>Available in backends: </p>"},{"location":"api/widgets/ListEdit/#signals","title":"Signals","text":"<ul> <li><code>changed(object)</code> - Emitted with <code>self</code> when any sub-widget in the container changes.</li> <li><code>label_changed(str)</code> - Emitted when the widget label changes.</li> <li><code>parent_changed(object)</code> - Emitted with the backend widget when the widget parent changes.</li> </ul>"},{"location":"api/widgets/ListEdit/#magicgui.widgets.ListEdit","title":"<code>ListEdit</code>","text":"<p>             Bases: <code>Container[ValueWidget[_V]]</code></p> <p>A widget to represent a list of values.</p> <pre><code>A ListEdit container can create a list with multiple objects of same type. It\nwill contain many child widgets and their value is represented as a Python list\nobject. If a list is given as the initial value, types of child widgets are\ndetermined from the contents. Number of contents can be adjusted with +/-\nbuttons.\n</code></pre> <p>Parameters:</p> <ul> <li> value             (<code>Iterable</code>, default:                 <code>Undefined</code> )         \u2013          <p>The starting value for the widget.</p> </li> <li> nullable             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, the widget will accepts <code>None</code> as a valid value, by default <code>False</code>.</p> </li> <li> options             (<code>dict</code>, default:                 <code>None</code> )         \u2013          <p>Widget options of child widgets.</p> </li> </ul>"},{"location":"api/widgets/ListEdit/#magicgui.widgets.ListEdit.annotation","title":"<code>annotation: Any</code>  <code>property</code> <code>writable</code>","text":"<p>Return type annotation for the parameter represented by the widget.</p> <p>ForwardRefs will be resolve when setting the annotation. For ListEdit, annotation will be like 'list[str]'.</p>"},{"location":"api/widgets/ListEdit/#magicgui.widgets.ListEdit.data","title":"<code>data: ListDataView[_V]</code>  <code>property</code> <code>writable</code>","text":"<p>Return a data view of current value.</p>"},{"location":"api/widgets/ListEdit/#magicgui.widgets.ListEdit.value","title":"<code>value: list[_V]</code>  <code>property</code> <code>writable</code>","text":"<p>Return current value as a list object.</p>"},{"location":"api/widgets/ListEdit/#magicgui.widgets.ListEdit.__delitem__","title":"<code>__delitem__(key: int | slice) -&gt; None</code>","text":"<p>Delete child widget(s).</p>"},{"location":"api/widgets/LiteralEvalLineEdit/","title":"LiteralEvalLineEdit","text":"<p>Available in backends: <code>qt</code>, <code>ipynb</code></p>"},{"location":"api/widgets/LiteralEvalLineEdit/#signals","title":"Signals","text":"<ul> <li><code>changed(object)</code> - Emitted when the widget value changes.</li> <li><code>label_changed(str)</code> - Emitted when the widget label changes.</li> <li><code>parent_changed(object)</code> - Emitted with the backend widget when the widget parent changes.</li> </ul>"},{"location":"api/widgets/LiteralEvalLineEdit/#magicgui.widgets.LiteralEvalLineEdit","title":"<code>LiteralEvalLineEdit</code>","text":"<p>             Bases: <code>ValueWidget[str]</code></p> <p>A one-line text editor that evaluates strings as python literals.</p> <p>Parameters:</p> <ul> <li> value             (<code>Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>The starting value for the widget.</p> </li> <li> bind             (<code>Callable[[ValueWidget], Any] | Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>A value or callback to bind this widget. If provided, whenever <code>widget.value</code> is accessed, the value provided here will be returned instead. <code>bind</code> may be a callable, in which case <code>bind(self)</code> will be returned (i.e. your bound callback must accept a single parameter, which is this widget instance).</p> </li> <li> nullable             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, the widget will accepts <code>None</code> as a valid value, by default <code>False</code>.</p> </li> <li> **base_widget_kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>All additional keyword arguments are passed to the base <code>magicgui.widgets.Widget</code> constructor.</p> </li> </ul>"},{"location":"api/widgets/LogSlider/","title":"LogSlider","text":"<p>Available in backends: </p>"},{"location":"api/widgets/LogSlider/#signals","title":"Signals","text":"<ul> <li><code>changed(object)</code> - Emitted when the widget value changes.</li> <li><code>label_changed(str)</code> - Emitted when the widget label changes.</li> <li><code>parent_changed(object)</code> - Emitted with the backend widget when the widget parent changes.</li> </ul>"},{"location":"api/widgets/LogSlider/#magicgui.widgets.LogSlider","title":"<code>LogSlider</code>","text":"<p>             Bases: <code>TransformedRangedWidget</code></p> <p>A slider widget to adjust a numerical value logarithmically within a range.</p> <p>Parameters:</p> <ul> <li> base             (<code>Enum, Iterable, or Callable</code>, default:                 <code>e</code> )         \u2013          <p>The base to use for the log, by default math.e.</p> </li> </ul>"},{"location":"api/widgets/LogSlider/#magicgui.widgets.LogSlider.base","title":"<code>base: float</code>  <code>property</code> <code>writable</code>","text":"<p>Return base used for the log.</p>"},{"location":"api/widgets/LogSlider/#magicgui.widgets.LogSlider.tracking","title":"<code>tracking: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Return whether slider tracking is enabled.</p> <p>If tracking is enabled (the default), the slider emits the changed() signal while the slider is being dragged. If tracking is disabled, the slider emits the changed() signal only when the user releases the slider.</p>"},{"location":"api/widgets/MainFunctionGui/","title":"MainFunctionGui","text":"<p>Available in backends: </p>"},{"location":"api/widgets/MainFunctionGui/#signals","title":"Signals","text":"<ul> <li><code>called(object)</code> - Emitted with the result after the function is called.</li> <li><code>changed(object)</code> - Emitted with <code>self</code> when any sub-widget in the container changes.</li> <li><code>label_changed(str)</code> - Emitted when the widget label changes.</li> <li><code>parent_changed(object)</code> - Emitted with the backend widget when the widget parent changes.</li> </ul>"},{"location":"api/widgets/MainFunctionGui/#magicgui.widgets.MainFunctionGui","title":"<code>MainFunctionGui</code>","text":"<p>             Bases: <code>FunctionGui[_P, _R]</code>, <code>MainWindow</code></p> <p>Container of widgets as a Main Application Window.</p>"},{"location":"api/widgets/MainWindow/","title":"MainWindow","text":"<p>Available in backends: <code>qt</code></p>"},{"location":"api/widgets/MainWindow/#signals","title":"Signals","text":"<ul> <li><code>changed(object)</code> - Emitted with <code>self</code> when any sub-widget in the container changes.</li> <li><code>label_changed(str)</code> - Emitted when the widget label changes.</li> <li><code>parent_changed(object)</code> - Emitted with the backend widget when the widget parent changes.</li> </ul>"},{"location":"api/widgets/MainWindow/#magicgui.widgets.MainWindow","title":"<code>MainWindow</code>","text":"<p>             Bases: <code>MainWindowWidget</code></p> <p>A Widget to contain other widgets, includes a menu bar.</p> <p>Parameters:</p> <ul> <li> widgets             (<code>Sequence[Widget]</code>, default:                 <code>()</code> )         \u2013          <p>A sequence of widgets with which to initialize the container, by default <code>None</code>.</p> </li> <li> layout             (<code>str</code>, default:                 <code>'vertical'</code> )         \u2013          <p>The layout for the container.  must be one of <code>{'horizontal', 'vertical'}</code>. by default \"vertical\"</p> </li> <li> scrollable             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to enable scroll bars or not. If enabled, scroll bars will only appear along the layout direction, not in both directions.</p> </li> <li> labels             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether each widget should be shown with a corresponding Label widget to the left, by default <code>True</code>.  Note: the text for each widget defaults to <code>widget.name</code>, but can be overridden by setting <code>widget.label</code>.</p> </li> <li> **base_widget_kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>All additional keyword arguments are passed to the base <code>magicgui.widgets.Widget</code> constructor.</p> </li> </ul>"},{"location":"api/widgets/Password/","title":"Password","text":"<p>Available in backends: <code>qt</code>, <code>ipynb</code></p>"},{"location":"api/widgets/Password/#signals","title":"Signals","text":"<ul> <li><code>changed(object)</code> - Emitted when the widget value changes.</li> <li><code>label_changed(str)</code> - Emitted when the widget label changes.</li> <li><code>parent_changed(object)</code> - Emitted with the backend widget when the widget parent changes.</li> </ul>"},{"location":"api/widgets/Password/#magicgui.widgets.Password","title":"<code>Password</code>","text":"<p>             Bases: <code>ValueWidget[str]</code></p> <p>A one-line text editor that obscures input.</p> <p>Parameters:</p> <ul> <li> value             (<code>Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>The starting value for the widget.</p> </li> <li> bind             (<code>Callable[[ValueWidget], Any] | Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>A value or callback to bind this widget. If provided, whenever <code>widget.value</code> is accessed, the value provided here will be returned instead. <code>bind</code> may be a callable, in which case <code>bind(self)</code> will be returned (i.e. your bound callback must accept a single parameter, which is this widget instance).</p> </li> <li> nullable             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, the widget will accepts <code>None</code> as a valid value, by default <code>False</code>.</p> </li> <li> **base_widget_kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>All additional keyword arguments are passed to the base <code>magicgui.widgets.Widget</code> constructor.</p> </li> </ul>"},{"location":"api/widgets/ProgressBar/","title":"ProgressBar","text":"<p>Available in backends: <code>qt</code></p>"},{"location":"api/widgets/ProgressBar/#signals","title":"Signals","text":"<ul> <li><code>changed(object)</code> - Emitted when the widget value changes.</li> <li><code>label_changed(str)</code> - Emitted when the widget label changes.</li> <li><code>parent_changed(object)</code> - Emitted with the backend widget when the widget parent changes.</li> </ul>"},{"location":"api/widgets/ProgressBar/#magicgui.widgets.ProgressBar","title":"<code>ProgressBar</code>","text":"<p>             Bases: <code>SliderWidget[float]</code></p> <p>A progress bar widget.</p> <p>Parameters:</p> <ul> <li> value             (<code>Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>The starting value for the widget.</p> </li> <li> min             (<code>float</code>, default:                 <code>Undefined</code> )         \u2013          <p>The minimum allowable value, by default 0 (or <code>value</code> if <code>value</code> is less than 0)</p> </li> <li> max             (<code>float</code>, default:                 <code>Undefined</code> )         \u2013          <p>The maximum allowable value, by default 999 (or <code>value</code> if <code>value</code> is greater than 999)</p> </li> <li> step             (<code>float</code>, default:                 <code>Undefined</code> )         \u2013          <p>The step size for incrementing the value, by default adaptive step is used</p> </li> <li> orientation             (<code>(str, {'horizontal', 'vertical'})</code>, default:                 <code>'horizontal'</code> )         \u2013          <p>The orientation for the slider, by default \"horizontal\"</p> </li> <li> readout             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to show the editable spinbox next to the slider</p> </li> <li> tracking             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>If tracking is enabled (the default), the slider emits the <code>changed</code> signal while the slider is being dragged. If tracking is disabled, the slider emits the <code>changed</code> signal only after the user releases the slider.</p> </li> <li> bind             (<code>Callable[[ValueWidget], Any] | Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>A value or callback to bind this widget. If provided, whenever <code>widget.value</code> is accessed, the value provided here will be returned instead. <code>bind</code> may be a callable, in which case <code>bind(self)</code> will be returned (i.e. your bound callback must accept a single parameter, which is this widget instance).</p> </li> <li> nullable             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, the widget will accepts <code>None</code> as a valid value, by default <code>False</code>.</p> </li> <li> **base_widget_kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>All additional keyword arguments are passed to the base <code>magicgui.widgets.Widget</code> constructor.</p> </li> </ul>"},{"location":"api/widgets/ProgressBar/#magicgui.widgets.ProgressBar.step","title":"<code>step: float</code>  <code>property</code> <code>writable</code>","text":"<p>Step size for widget values.</p>"},{"location":"api/widgets/ProgressBar/#magicgui.widgets.ProgressBar.decrement","title":"<code>decrement(val: float | None = None) -&gt; None</code>","text":"<p>Decrease current value by step size, or provided value.</p>"},{"location":"api/widgets/ProgressBar/#magicgui.widgets.ProgressBar.increment","title":"<code>increment(val: float | None = None) -&gt; None</code>","text":"<p>Increase current value by step size, or provided value.</p>"},{"location":"api/widgets/PushButton/","title":"PushButton","text":"<p>Available in backends: <code>qt</code>, <code>ipynb</code></p>"},{"location":"api/widgets/PushButton/#signals","title":"Signals","text":"<ul> <li><code>changed(object)</code> - Emitted when the button is clicked (may also be connected at the alias <code>clicked</code>).</li> <li><code>label_changed(str)</code> - Emitted when the widget label changes.</li> <li><code>parent_changed(object)</code> - Emitted with the backend widget when the widget parent changes.</li> </ul>"},{"location":"api/widgets/PushButton/#magicgui.widgets.PushButton","title":"<code>PushButton</code>","text":"<p>             Bases: <code>ButtonWidget</code></p> <p>A clickable command button.</p> <p>Parameters:</p> <ul> <li> value             (<code>bool</code>, default:                 <code>Undefined</code> )         \u2013          <p>The starting state of the widget.</p> </li> <li> text             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>The text to display on the button. If not provided, will use <code>name</code>.</p> </li> <li> bind             (<code>Callable[[ValueWidget], Any] | Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>A value or callback to bind this widget. If provided, whenever <code>widget.value</code> is accessed, the value provided here will be returned instead. <code>bind</code> may be a callable, in which case <code>bind(self)</code> will be returned (i.e. your bound callback must accept a single parameter, which is this widget instance).</p> </li> <li> nullable             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, the widget will accepts <code>None</code> as a valid value, by default <code>False</code>.</p> </li> <li> **base_widget_kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>All additional keyword arguments are passed to the base <code>magicgui.widgets.Widget</code> constructor.</p> </li> </ul>"},{"location":"api/widgets/QuantityEdit/","title":"QuantityEdit","text":"<p>Available in backends: <code>qt</code></p>"},{"location":"api/widgets/QuantityEdit/#signals","title":"Signals","text":"<ul> <li><code>changed(object)</code> - Emitted when the widget value changes.</li> <li><code>label_changed(str)</code> - Emitted when the widget label changes.</li> <li><code>parent_changed(object)</code> - Emitted with the backend widget when the widget parent changes.</li> </ul>"},{"location":"api/widgets/QuantityEdit/#magicgui.widgets.QuantityEdit","title":"<code>QuantityEdit</code>","text":"<p>             Bases: <code>ValueWidget</code></p> <p>A combined <code>LineEdit</code> and <code>ComboBox</code> to edit a <code>pint.Quantity</code>.</p> <p>Parameters:</p> <ul> <li> value             (<code>Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>The starting value for the widget.</p> </li> <li> bind             (<code>Callable[[ValueWidget], Any] | Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>A value or callback to bind this widget. If provided, whenever <code>widget.value</code> is accessed, the value provided here will be returned instead. <code>bind</code> may be a callable, in which case <code>bind(self)</code> will be returned (i.e. your bound callback must accept a single parameter, which is this widget instance).</p> </li> <li> nullable             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, the widget will accepts <code>None</code> as a valid value, by default <code>False</code>.</p> </li> <li> **base_widget_kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>All additional keyword arguments are passed to the base <code>magicgui.widgets.Widget</code> constructor.</p> </li> </ul>"},{"location":"api/widgets/RadioButton/","title":"RadioButton","text":"<p>Available in backends: <code>qt</code>, <code>ipynb</code></p>"},{"location":"api/widgets/RadioButton/#signals","title":"Signals","text":"<ul> <li><code>changed(object)</code> - Emitted when the button is clicked (may also be connected at the alias <code>clicked</code>).</li> <li><code>label_changed(str)</code> - Emitted when the widget label changes.</li> <li><code>parent_changed(object)</code> - Emitted with the backend widget when the widget parent changes.</li> </ul>"},{"location":"api/widgets/RadioButton/#magicgui.widgets.RadioButton","title":"<code>RadioButton</code>","text":"<p>             Bases: <code>ButtonWidget</code></p> <p>A radio button with a text label.</p> <p>Parameters:</p> <ul> <li> value             (<code>bool</code>, default:                 <code>Undefined</code> )         \u2013          <p>The starting state of the widget.</p> </li> <li> text             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>The text to display on the button. If not provided, will use <code>name</code>.</p> </li> <li> bind             (<code>Callable[[ValueWidget], Any] | Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>A value or callback to bind this widget. If provided, whenever <code>widget.value</code> is accessed, the value provided here will be returned instead. <code>bind</code> may be a callable, in which case <code>bind(self)</code> will be returned (i.e. your bound callback must accept a single parameter, which is this widget instance).</p> </li> <li> nullable             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, the widget will accepts <code>None</code> as a valid value, by default <code>False</code>.</p> </li> <li> **base_widget_kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>All additional keyword arguments are passed to the base <code>magicgui.widgets.Widget</code> constructor.</p> </li> </ul>"},{"location":"api/widgets/RadioButtons/","title":"RadioButtons","text":"<p>Available in backends: <code>qt</code></p>"},{"location":"api/widgets/RadioButtons/#signals","title":"Signals","text":"<ul> <li><code>changed(object)</code> - Emitted when the widget value changes.</li> <li><code>label_changed(str)</code> - Emitted when the widget label changes.</li> <li><code>parent_changed(object)</code> - Emitted with the backend widget when the widget parent changes.</li> </ul>"},{"location":"api/widgets/RadioButtons/#magicgui.widgets.RadioButtons","title":"<code>RadioButtons</code>","text":"<p>             Bases: <code>CategoricalWidget</code>, <code>_OrientationMixin</code></p> <p>An exclusive group of radio buttons, providing a choice from multiple choices.</p> <p>Parameters:</p> <ul> <li> value             (<code>Any</code>)         \u2013          <p>The initially selected choice.</p> </li> <li> choices             (<code>Enum, Iterable, or Callable</code>, default:                 <code>()</code> )         \u2013          <p>Available choices displayed in the combo box.</p> </li> <li> bind             (<code>Callable[[ValueWidget], Any] | Any</code>)         \u2013          <p>A value or callback to bind this widget. If provided, whenever <code>widget.value</code> is accessed, the value provided here will be returned instead. <code>bind</code> may be a callable, in which case <code>bind(self)</code> will be returned (i.e. your bound callback must accept a single parameter, which is this widget instance).</p> </li> <li> nullable             (<code>bool</code>)         \u2013          <p>If <code>True</code>, the widget will accepts <code>None</code> as a valid value, by default <code>False</code>.</p> </li> <li> **base_widget_kwargs             (<code>Any</code>)         \u2013          <p>All additional keyword arguments are passed to the base <code>magicgui.widgets.Widget</code> constructor.</p> </li> </ul>"},{"location":"api/widgets/RangeEdit/","title":"RangeEdit","text":"<p>Available in backends: </p>"},{"location":"api/widgets/RangeEdit/#signals","title":"Signals","text":"<ul> <li><code>changed(object)</code> - Emitted with <code>self</code> when any sub-widget in the container changes.</li> <li><code>label_changed(str)</code> - Emitted when the widget label changes.</li> <li><code>parent_changed(object)</code> - Emitted with the backend widget when the widget parent changes.</li> </ul>"},{"location":"api/widgets/RangeEdit/#magicgui.widgets.RangeEdit","title":"<code>RangeEdit</code>","text":"<p>             Bases: <code>Container[SpinBox]</code></p> <p>A widget to represent a python range object, with start/stop/step.</p> <pre><code>A range object produces a sequence of integers from start (inclusive)\nto stop (exclusive) by step.  range(i, j) produces i, i+1, i+2, ..., j-1.\nstart defaults to 0, and stop is omitted!  range(4) produces 0, 1, 2, 3.\nThese are exactly the valid indices for a list of 4 elements.\nWhen step is given, it specifies the increment (or decrement).\n</code></pre> <p>Parameters:</p> <ul> <li> start             (<code>int</code>, default:                 <code>0</code> )         \u2013          <p>The range start value, by default 0</p> </li> <li> stop             (<code>int</code>, default:                 <code>10</code> )         \u2013          <p>The range stop value, by default 10</p> </li> <li> step             (<code>int</code>, default:                 <code>1</code> )         \u2013          <p>The range step value, by default 1</p> </li> </ul>"},{"location":"api/widgets/RangeEdit/#magicgui.widgets.RangeEdit.value","title":"<code>value: range</code>  <code>property</code> <code>writable</code>","text":"<p>Return current value of the widget.  This may be interpreted by backends.</p>"},{"location":"api/widgets/RangeEdit/#magicgui.widgets.RangeEdit.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Return string representation.</p>"},{"location":"api/widgets/RangeSlider/","title":"RangeSlider","text":"<p>Available in backends: <code>qt</code></p>"},{"location":"api/widgets/RangeSlider/#signals","title":"Signals","text":"<ul> <li><code>changed(object)</code> - Emitted when the widget value changes.</li> <li><code>label_changed(str)</code> - Emitted when the widget label changes.</li> <li><code>parent_changed(object)</code> - Emitted with the backend widget when the widget parent changes.</li> </ul>"},{"location":"api/widgets/RangeSlider/#magicgui.widgets.RangeSlider","title":"<code>RangeSlider</code>","text":"<p>             Bases: <code>MultiValuedSliderWidget</code></p> <p>A slider widget to adjust a range between two integer values within a range.</p> <p>Parameters:</p> <ul> <li> value             (<code>Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>The starting value for the widget.</p> </li> <li> min             (<code>float</code>, default:                 <code>Undefined</code> )         \u2013          <p>The minimum allowable value, by default 0 (or <code>value</code> if <code>value</code> is less than 0)</p> </li> <li> max             (<code>float</code>, default:                 <code>Undefined</code> )         \u2013          <p>The maximum allowable value, by default 999 (or <code>value</code> if <code>value</code> is greater than 999)</p> </li> <li> step             (<code>float</code>, default:                 <code>Undefined</code> )         \u2013          <p>The step size for incrementing the value, by default adaptive step is used</p> </li> <li> orientation             (<code>(str, {'horizontal', 'vertical'})</code>, default:                 <code>'horizontal'</code> )         \u2013          <p>The orientation for the slider, by default \"horizontal\"</p> </li> <li> readout             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to show the editable spinbox next to the slider</p> </li> <li> tracking             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>If tracking is enabled (the default), the slider emits the <code>changed</code> signal while the slider is being dragged. If tracking is disabled, the slider emits the <code>changed</code> signal only after the user releases the slider.</p> </li> <li> bind             (<code>Callable[[ValueWidget], Any] | Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>A value or callback to bind this widget. If provided, whenever <code>widget.value</code> is accessed, the value provided here will be returned instead. <code>bind</code> may be a callable, in which case <code>bind(self)</code> will be returned (i.e. your bound callback must accept a single parameter, which is this widget instance).</p> </li> <li> nullable             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, the widget will accepts <code>None</code> as a valid value, by default <code>False</code>.</p> </li> <li> **base_widget_kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>All additional keyword arguments are passed to the base <code>magicgui.widgets.Widget</code> constructor.</p> </li> </ul>"},{"location":"api/widgets/Select/","title":"Select","text":"<p>Available in backends: <code>qt</code>, <code>ipynb</code></p>"},{"location":"api/widgets/Select/#signals","title":"Signals","text":"<ul> <li><code>changed(object)</code> - Emitted when the widget value changes.</li> <li><code>label_changed(str)</code> - Emitted when the widget label changes.</li> <li><code>parent_changed(object)</code> - Emitted with the backend widget when the widget parent changes.</li> </ul>"},{"location":"api/widgets/Select/#magicgui.widgets.Select","title":"<code>Select</code>","text":"<p>             Bases: <code>CategoricalWidget</code></p> <p>A list of options, allowing selection between multiple choices.</p> <p>Parameters:</p> <ul> <li> value             (<code>Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>The initially selected choice.</p> </li> <li> choices             (<code>Enum, Iterable, or Callable</code>, default:                 <code>()</code> )         \u2013          <p>Available choices displayed in the combo box.</p> </li> <li> bind             (<code>Callable[[ValueWidget], Any] | Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>A value or callback to bind this widget. If provided, whenever <code>widget.value</code> is accessed, the value provided here will be returned instead. <code>bind</code> may be a callable, in which case <code>bind(self)</code> will be returned (i.e. your bound callback must accept a single parameter, which is this widget instance).</p> </li> <li> nullable             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, the widget will accepts <code>None</code> as a valid value, by default <code>False</code>.</p> </li> <li> **base_widget_kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>All additional keyword arguments are passed to the base <code>magicgui.widgets.Widget</code> constructor.</p> </li> </ul>"},{"location":"api/widgets/SliceEdit/","title":"SliceEdit","text":"<p>Available in backends: </p>"},{"location":"api/widgets/SliceEdit/#signals","title":"Signals","text":"<ul> <li><code>changed(object)</code> - Emitted with <code>self</code> when any sub-widget in the container changes.</li> <li><code>label_changed(str)</code> - Emitted when the widget label changes.</li> <li><code>parent_changed(object)</code> - Emitted with the backend widget when the widget parent changes.</li> </ul>"},{"location":"api/widgets/SliceEdit/#magicgui.widgets.SliceEdit","title":"<code>SliceEdit</code>","text":"<p>             Bases: <code>RangeEdit</code></p> <p>A widget to represent <code>slice</code> objects, with start/stop/step.</p> <p>slice(stop) slice(start, stop[, step])</p> <p>Slice objects may be used for extended slicing (e.g. a[0:10:2])</p>"},{"location":"api/widgets/SliceEdit/#magicgui.widgets.SliceEdit.value","title":"<code>value: slice</code>  <code>property</code> <code>writable</code>","text":"<p>Return current value of the widget.  This may be interpreted by backends.</p>"},{"location":"api/widgets/Slider/","title":"Slider","text":"<p>Available in backends: <code>qt</code>, <code>ipynb</code></p>"},{"location":"api/widgets/Slider/#signals","title":"Signals","text":"<ul> <li><code>changed(object)</code> - Emitted when the widget value changes.</li> <li><code>label_changed(str)</code> - Emitted when the widget label changes.</li> <li><code>parent_changed(object)</code> - Emitted with the backend widget when the widget parent changes.</li> </ul>"},{"location":"api/widgets/Slider/#magicgui.widgets.Slider","title":"<code>Slider</code>","text":"<p>             Bases: <code>SliderWidget[int]</code></p> <p>A slider widget to adjust an integer value within a range.</p> <p>Parameters:</p> <ul> <li> value             (<code>Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>The starting value for the widget.</p> </li> <li> min             (<code>float</code>, default:                 <code>Undefined</code> )         \u2013          <p>The minimum allowable value, by default 0 (or <code>value</code> if <code>value</code> is less than 0)</p> </li> <li> max             (<code>float</code>, default:                 <code>Undefined</code> )         \u2013          <p>The maximum allowable value, by default 999 (or <code>value</code> if <code>value</code> is greater than 999)</p> </li> <li> step             (<code>float</code>, default:                 <code>Undefined</code> )         \u2013          <p>The step size for incrementing the value, by default adaptive step is used</p> </li> <li> orientation             (<code>(str, {'horizontal', 'vertical'})</code>, default:                 <code>'horizontal'</code> )         \u2013          <p>The orientation for the slider, by default \"horizontal\"</p> </li> <li> readout             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to show the editable spinbox next to the slider</p> </li> <li> tracking             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>If tracking is enabled (the default), the slider emits the <code>changed</code> signal while the slider is being dragged. If tracking is disabled, the slider emits the <code>changed</code> signal only after the user releases the slider.</p> </li> <li> bind             (<code>Callable[[ValueWidget], Any] | Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>A value or callback to bind this widget. If provided, whenever <code>widget.value</code> is accessed, the value provided here will be returned instead. <code>bind</code> may be a callable, in which case <code>bind(self)</code> will be returned (i.e. your bound callback must accept a single parameter, which is this widget instance).</p> </li> <li> nullable             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, the widget will accepts <code>None</code> as a valid value, by default <code>False</code>.</p> </li> <li> **base_widget_kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>All additional keyword arguments are passed to the base <code>magicgui.widgets.Widget</code> constructor.</p> </li> </ul>"},{"location":"api/widgets/SpinBox/","title":"SpinBox","text":"<p>Available in backends: <code>qt</code>, <code>ipynb</code></p>"},{"location":"api/widgets/SpinBox/#signals","title":"Signals","text":"<ul> <li><code>changed(object)</code> - Emitted when the widget value changes.</li> <li><code>label_changed(str)</code> - Emitted when the widget label changes.</li> <li><code>parent_changed(object)</code> - Emitted with the backend widget when the widget parent changes.</li> </ul>"},{"location":"api/widgets/SpinBox/#magicgui.widgets.SpinBox","title":"<code>SpinBox</code>","text":"<p>             Bases: <code>RangedWidget[int]</code></p> <p>A widget to edit an integer with clickable up/down arrows.</p> <p>Parameters:</p> <ul> <li> value             (<code>Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>The starting value for the widget.</p> </li> <li> min             (<code>float</code>, default:                 <code>Undefined</code> )         \u2013          <p>The minimum allowable value, by default 0 (or <code>value</code> if <code>value</code> is less than 0)</p> </li> <li> max             (<code>float</code>, default:                 <code>Undefined</code> )         \u2013          <p>The maximum allowable value, by default 999 (or <code>value</code> if <code>value</code> is greater than 999)</p> </li> <li> step             (<code>float</code>, default:                 <code>Undefined</code> )         \u2013          <p>The step size for incrementing the value, by default adaptive step is used</p> </li> <li> bind             (<code>Callable[[ValueWidget], Any] | Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>A value or callback to bind this widget. If provided, whenever <code>widget.value</code> is accessed, the value provided here will be returned instead. <code>bind</code> may be a callable, in which case <code>bind(self)</code> will be returned (i.e. your bound callback must accept a single parameter, which is this widget instance).</p> </li> <li> nullable             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, the widget will accepts <code>None</code> as a valid value, by default <code>False</code>.</p> </li> <li> **base_widget_kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>All additional keyword arguments are passed to the base <code>magicgui.widgets.Widget</code> constructor.</p> </li> </ul>"},{"location":"api/widgets/Table/","title":"Table","text":"<p>Available in backends: <code>qt</code></p>"},{"location":"api/widgets/Table/#signals","title":"Signals","text":"<ul> <li><code>changed(object)</code> - Emitted when the widget value changes.</li> <li><code>label_changed(str)</code> - Emitted when the widget label changes.</li> <li><code>parent_changed(object)</code> - Emitted with the backend widget when the widget parent changes.</li> </ul>"},{"location":"api/widgets/Table/#magicgui.widgets.Table","title":"<code>Table</code>","text":"<p>             Bases: <code>ValueWidget</code>, <code>_ReadOnlyMixin</code>, <code>MutableMapping[TblKey, list]</code></p> <p>A widget to represent columnar or 2D data with headers.</p> <p>Tables behave like plain <code>dicts</code>, where the keys are column headers and the (list-like) values are column data.</p> <p>Parameters:</p> <ul> <li> value             (<code>(dict, dataframe, list, array, tuple)</code>, default:                 <code>None</code> )         \u2013          <p>Table data (and/or header data), in one of the accepted formats:</p> <ul> <li>list or list-of-lists : [column_values] or [[row_vals], ..., [row_vals]]</li> <li>dict-of-dicts : {column_header -&gt; {row_header -&gt; value}}</li> <li>dict-of-lists : {column_header -&gt; [column_values]}</li> <li>list-of-row-records :     [{column_headers -&gt; value}, ... , {column_headers -&gt; value}]</li> <li>split-dict-of-lists :</li> <li>tuple-of-values : ([values], [row_headers], [column_headers])</li> <li>dict-of-pandas-series : {column_header -&gt; Series(values)}</li> </ul> </li> </ul> <p>index : Collection, optional     A sized iterable container of row headers. By default, row headers will be     <code>tuple(range(len(data)))</code>.  Values provided here override any implied in     <code>value</code>. columns : Collection, optional     A sized iterable container of column headers. By default, column headers will be     <code>tuple(range(len(data[0])))</code>.  Values provided here override any implied in     <code>value</code>. **kwargs     Additional kwargs will be passed to the     magicgui.widgets.Widget constructor.</p> <p>Attributes:</p> <ul> <li> value             (<code>dict</code>)         \u2013          <p>Returns a dict with the keys <code>data</code>, <code>index</code>, and <code>columns</code> ... representing the 2D (list of lists) tabular data, row headers, and column headers, respectively. If set, will clear and update the table using the new data.</p> </li> <li> data             (<code>DataView</code>)         \u2013          <p>A <code>DataView</code> instance that provides numpy-like indexing (with get/set/delete) onto the 2D data array,  For example <code>table.data[0,2]</code> gets the data in the cell of the first row, 3rd column.  Works with numpy slice syntax.</p> </li> <li> column_headers             (<code>tuple</code>)         \u2013          <p>The current column headers.  Can be set with a new sequence to change</p> </li> <li> row_headers             (<code>tuple</code>)         \u2013          <p>The current row headers.  Can be set with a new sequence to change</p> </li> <li> shape             (<code>tuple of int</code>)         \u2013          <p>The shape of the table in <code>(rows, columns)</code>.</p> </li> <li> size             (<code>int</code>)         \u2013          <p>The number of cells in the table.</p> </li> </ul> <p>Methods:</p> <ul> <li> keys           \u2013            <p>Return a <code>TableHeadersView</code>, providing a view on this table's headers. Use <code>axis='row'</code> for row headers.</p> </li> <li> items           \u2013            <p>Return a <code>TableItemsView</code>, providing a view on this table's items, as 2-tuples of <code>(header, data)</code>. Use <code>axis='row'</code> for <code>(row_header, row_data)</code></p> </li> <li> clear           \u2013            <p>Clear all table data and headers.</p> </li> <li> to_dataframe           \u2013            <p>Returns a pandas dataframe representation of this table. (requires pandas)</p> </li> <li> to_dict           \u2013            <p>Return one of many different dict-like representations of table and header data. See docstring of :meth:<code>to_dict</code> for details.</p> </li> </ul>"},{"location":"api/widgets/Table/#magicgui.widgets.Table--events","title":"Events","text":"<p>changed     Emitted whenever a cell in the table changes. The value will have a     dict of information regarding the cell that changed:     {'data': x, 'row': int, 'column': int, 'column_header': str, 'row_header': str}     CURRENTLY: only emitted on changes in the GUI. not programmatic changes.</p>"},{"location":"api/widgets/Table/#magicgui.widgets.Table.column_headers","title":"<code>column_headers: tuple</code>  <code>property</code> <code>writable</code>","text":"<p>Return column headers.</p>"},{"location":"api/widgets/Table/#magicgui.widgets.Table.data","title":"<code>data: DataView</code>  <code>property</code> <code>writable</code>","text":"<p>Return DataView object for this table.</p>"},{"location":"api/widgets/Table/#magicgui.widgets.Table.row_headers","title":"<code>row_headers: tuple</code>  <code>property</code> <code>writable</code>","text":"<p>Return row headers.</p>"},{"location":"api/widgets/Table/#magicgui.widgets.Table.shape","title":"<code>shape: tuple[int, int]</code>  <code>property</code>","text":"<p>Return shape of table widget (rows, cols).</p>"},{"location":"api/widgets/Table/#magicgui.widgets.Table.size","title":"<code>size: int</code>  <code>property</code>","text":"<p>Return shape of table widget (rows, cols).</p>"},{"location":"api/widgets/Table/#magicgui.widgets.Table.value","title":"<code>value: dict[TblKey, Collection]</code>  <code>property</code> <code>writable</code>","text":"<p>Return dict with current <code>data</code>, <code>index</code>, and <code>columns</code> of the widget.</p>"},{"location":"api/widgets/Table/#magicgui.widgets.Table.__delitem__","title":"<code>__delitem__(key: TblKey) -&gt; None</code>","text":"<p>Delete a column from the table.</p>"},{"location":"api/widgets/Table/#magicgui.widgets.Table.__getitem__","title":"<code>__getitem__(key: TblKey) -&gt; list</code>","text":"<p>Get a column from the table.</p>"},{"location":"api/widgets/Table/#magicgui.widgets.Table.__hash__","title":"<code>__hash__() -&gt; int</code>","text":"<p>Make table hashable.</p>"},{"location":"api/widgets/Table/#magicgui.widgets.Table.__iter__","title":"<code>__iter__() -&gt; Iterator</code>","text":"<p>Yield column headers.</p>"},{"location":"api/widgets/Table/#magicgui.widgets.Table.__len__","title":"<code>__len__() -&gt; int</code>","text":"<p>Return number of columns.</p>"},{"location":"api/widgets/Table/#magicgui.widgets.Table.__new__","title":"<code>__new__(value: TableData | None = None, *, index: Collection | None = None, columns: Collection | None = None, **kwargs: Any) -&gt; Table</code>","text":"<p>Just for the signature.</p>"},{"location":"api/widgets/Table/#magicgui.widgets.Table.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Return string repr.</p>"},{"location":"api/widgets/Table/#magicgui.widgets.Table.__setitem__","title":"<code>__setitem__(key: TblKey, v: Collection) -&gt; None</code>","text":"<p>Set a column in the table. If <code>k</code> doesn't exist, make a new column.</p>"},{"location":"api/widgets/Table/#magicgui.widgets.Table.clear","title":"<code>clear() -&gt; None</code>","text":"<p>Clear the table.</p>"},{"location":"api/widgets/Table/#magicgui.widgets.Table.items","title":"<code>items(axis: str = 'column') -&gt; TableItemsView[TblKey, list]</code>","text":"<p>Return a set-like object providing a view on this table's items.</p>"},{"location":"api/widgets/Table/#magicgui.widgets.Table.keys","title":"<code>keys(axis: str = 'column') -&gt; HeadersView[TblKey]</code>","text":"<p>Return a set-like object providing a view on this table's headers.</p>"},{"location":"api/widgets/Table/#magicgui.widgets.Table.to_dataframe","title":"<code>to_dataframe() -&gt; pandas.DataFrame</code>","text":"<p>Convert TableData to dataframe.</p>"},{"location":"api/widgets/Table/#magicgui.widgets.Table.to_dict","title":"<code>to_dict(orient: str = 'dict') -&gt; list | dict</code>","text":"<p>Convert the Table to a dictionary.</p> <p>The type of the key-value pairs can be customized with the parameters (see below).</p> <p>Parameters:</p> <ul> <li> orient             (<code>str {'dict', 'list', 'series', 'split', 'records', 'index'}</code>, default:                 <code>'dict'</code> )         \u2013          <p>Determines the type of the values of the dictionary.</p> <ul> <li>'dict' (default) : dict like {column -&gt; {index -&gt; value}}</li> <li>'list' : dict like {column -&gt; [values]}</li> <li>'split' : dict like</li> <li>'records' : list like   [{column -&gt; value}, ... , {column -&gt; value}]</li> <li>'index' : dict like {index -&gt; {column -&gt; value}}</li> <li>'series' : dict like {column -&gt; Series(values)}</li> </ul> </li> </ul>"},{"location":"api/widgets/TextEdit/","title":"TextEdit","text":"<p>Available in backends: <code>qt</code>, <code>ipynb</code></p>"},{"location":"api/widgets/TextEdit/#signals","title":"Signals","text":"<ul> <li><code>changed(object)</code> - Emitted when the widget value changes.</li> <li><code>label_changed(str)</code> - Emitted when the widget label changes.</li> <li><code>parent_changed(object)</code> - Emitted with the backend widget when the widget parent changes.</li> </ul>"},{"location":"api/widgets/TextEdit/#magicgui.widgets.TextEdit","title":"<code>TextEdit</code>","text":"<p>             Bases: <code>ValueWidget[str]</code>, <code>_ReadOnlyMixin</code></p> <p>A widget to edit and display both plain and rich text.</p> <p>Parameters:</p> <ul> <li> value             (<code>Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>The starting value for the widget.</p> </li> <li> bind             (<code>Callable[[ValueWidget], Any] | Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>A value or callback to bind this widget. If provided, whenever <code>widget.value</code> is accessed, the value provided here will be returned instead. <code>bind</code> may be a callable, in which case <code>bind(self)</code> will be returned (i.e. your bound callback must accept a single parameter, which is this widget instance).</p> </li> <li> nullable             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, the widget will accepts <code>None</code> as a valid value, by default <code>False</code>.</p> </li> <li> **base_widget_kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>All additional keyword arguments are passed to the base <code>magicgui.widgets.Widget</code> constructor.</p> </li> </ul>"},{"location":"api/widgets/TimeEdit/","title":"TimeEdit","text":"<p>Available in backends: <code>qt</code>, <code>ipynb</code></p>"},{"location":"api/widgets/TimeEdit/#signals","title":"Signals","text":"<ul> <li><code>changed(object)</code> - Emitted when the widget value changes.</li> <li><code>label_changed(str)</code> - Emitted when the widget label changes.</li> <li><code>parent_changed(object)</code> - Emitted with the backend widget when the widget parent changes.</li> </ul>"},{"location":"api/widgets/TimeEdit/#magicgui.widgets.TimeEdit","title":"<code>TimeEdit</code>","text":"<p>             Bases: <code>ValueWidget[TV]</code></p> <p>A widget for editing times.</p> <p>Parameters:</p> <ul> <li> value             (<code>Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>The starting value for the widget.</p> </li> <li> bind             (<code>Callable[[ValueWidget], Any] | Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>A value or callback to bind this widget. If provided, whenever <code>widget.value</code> is accessed, the value provided here will be returned instead. <code>bind</code> may be a callable, in which case <code>bind(self)</code> will be returned (i.e. your bound callback must accept a single parameter, which is this widget instance).</p> </li> <li> nullable             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, the widget will accepts <code>None</code> as a valid value, by default <code>False</code>.</p> </li> <li> **base_widget_kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>All additional keyword arguments are passed to the base <code>magicgui.widgets.Widget</code> constructor.</p> </li> </ul>"},{"location":"api/widgets/ToolBar/","title":"ToolBar","text":"<p>Available in backends: <code>qt</code>, <code>ipynb</code></p>"},{"location":"api/widgets/ToolBar/#signals","title":"Signals","text":"<ul> <li><code>label_changed(str)</code> - Emitted when the widget label changes.</li> <li><code>parent_changed(object)</code> - Emitted with the backend widget when the widget parent changes.</li> </ul>"},{"location":"api/widgets/ToolBar/#magicgui.widgets.ToolBar","title":"<code>ToolBar</code>","text":"<p>             Bases: <code>ToolBarWidget</code></p> <p>Toolbar that contains a set of controls.</p> <p>Parameters:</p> <ul> <li> **base_widget_kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>All additional keyword arguments are passed to the base <code>magicgui.widgets.Widget</code> constructor.</p> </li> </ul>"},{"location":"api/widgets/TupleEdit/","title":"TupleEdit","text":"<p>Available in backends: </p>"},{"location":"api/widgets/TupleEdit/#signals","title":"Signals","text":"<ul> <li><code>changed(object)</code> - Emitted with <code>self</code> when any sub-widget in the container changes.</li> <li><code>label_changed(str)</code> - Emitted when the widget label changes.</li> <li><code>parent_changed(object)</code> - Emitted with the backend widget when the widget parent changes.</li> </ul>"},{"location":"api/widgets/TupleEdit/#magicgui.widgets.TupleEdit","title":"<code>TupleEdit</code>","text":"<p>             Bases: <code>Container[ValueWidget]</code></p> <p>A widget to represent a tuple of values.</p> <pre><code>A TupleEdit container has several child widgets of different type. Their value is\nrepresented as a Python tuple object. If a tuple is given as the initial value,\ntypes of child widgets are determined one by one. Unlike ListEdit, number of\ncontents is not editable.\n</code></pre> <p>Parameters:</p> <ul> <li> value             (<code>Iterable</code>, default:                 <code>Undefined</code> )         \u2013          <p>The starting value for the widget.</p> </li> <li> nullable             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, the widget will accepts <code>None</code> as a valid value, by default <code>False</code>.</p> </li> <li> options             (<code>dict</code>, default:                 <code>None</code> )         \u2013          <p>Widget options of child widgets.</p> </li> </ul>"},{"location":"api/widgets/TupleEdit/#magicgui.widgets.TupleEdit.annotation","title":"<code>annotation: Any</code>  <code>property</code> <code>writable</code>","text":"<p>Return type annotation for the parameter represented by the widget.</p> <p>ForwardRefs will be resolve when setting the annotation. For TupleEdit, annotation will be like 'tuple[str, int]'.</p>"},{"location":"api/widgets/TupleEdit/#magicgui.widgets.TupleEdit.value","title":"<code>value: tuple</code>  <code>property</code> <code>writable</code>","text":"<p>Return current value as a tuple.</p>"},{"location":"api/widgets/bases/","title":"<code>magicgui.widgets.bases</code>","text":"<p>The <code>magicgui.widgets.bases</code> module contains the base classes for all widgets.</p> <p>While most users will never instantiate these classes directly, the methods and properties of these classes are inherited by all widgets, and define the common API for all widgets.  Therefore, it is worth being aware of the type of widget you are working with.</p>"},{"location":"api/widgets/bases/#summary","title":"Summary","text":"Widget Description <code>Widget</code> Basic Widget, wrapping a class that implements WidgetProtocol. <code>ButtonWidget</code> Widget with a value, Wraps a widget implementing the ButtonWidgetProtocol. <code>CategoricalWidget</code> Widget with a value and choices.  Wraps CategoricalWidgetProtocol. <code>ContainerWidget</code> Widget that can contain other widgets. <code>DialogWidget</code> Modal Container. <code>MainWindowWidget</code> Top level Application widget that can contain other widgets. <code>RangedWidget</code> Widget with a constrained value. Wraps RangedWidgetProtocol. <code>SliderWidget</code> Widget with a constrained value and orientation. Wraps SliderWidgetProtocol. <code>ValueWidget</code> Widget with a value, Wraps ValueWidgetProtocol."},{"location":"api/widgets/bases/#class-hierarchy","title":"Class Hierarchy","text":"<p>In visual form, the widget class hierarchy looks like this:</p> <pre><code>classDiagram\n    Widget &lt;|-- ValueWidget\n    Widget &lt;|-- ContainerWidget\n    BackendWidget ..|&gt; WidgetProtocol : implements a\n    ValueWidget &lt;|-- RangedWidget\n    ValueWidget &lt;|-- ButtonWidget\n    ValueWidget &lt;|-- CategoricalWidget\n    RangedWidget &lt;|-- SliderWidget\n    Widget --* WidgetProtocol : controls a\n    &lt;&lt;Interface&gt;&gt; WidgetProtocol\n    class WidgetProtocol {\n        _mgui_get_X()\n        _mgui_set_X()\n    }\n    class Widget{\n        name: str\n        annotation: Any\n        label: str\n        tooltip: str\n        visible: bool\n        enabled: bool\n        native: Any\n        height: int\n        width: int\n        hide()\n        show()\n        close()\n        render()\n    }\n    class ValueWidget{\n        value: Any\n        changed: SignalInstance\n        bind(value, call) Any\n        unbind()\n    }\n    class RangedWidget{\n        value: float | tuple\n        min: float\n        max: float\n        step: float\n        adaptive_step: bool\n        range: tuple[float, float]\n    }\n    class SliderWidget{\n        orientation: str\n    }\n    class ButtonWidget{\n        value: bool\n        clicked: SignalInstance\n        text: str\n    }\n    class CategoricalWidget{\n        choices: List[Any]\n    }\n    class ContainerWidget{\n        widgets: List[Widget]\n        labels: bool\n        layout: str\n        margins: tuple[int, int, int, int]\n        reset_choices()\n        asdict() Dict[str, Any]\n        update(mapping)\n    }\n\n    click Widget href \"#magicgui.widgets.bases.Widget\"\n    click ValueWidget href \"#magicgui.widgets.bases.ValueWidget\"\n    click RangedWidget href \"#magicgui.widgets.bases.RangedWidget\"\n    click SliderWidget href \"#magicgui.widgets.bases.SliderWidget\"\n    click ButtonWidget href \"#magicgui.widgets.bases.ButtonWidget\"\n    click CategoricalWidget href \"#magicgui.widgets.bases.CategoricalWidget\"\n    click ContainerWidget href \"#magicgui.widgets.bases.ContainerWidget\"\n</code></pre>"},{"location":"api/widgets/bases/#base-widget-classes","title":"Base Widget Classes","text":""},{"location":"api/widgets/bases/#magicgui.widgets.bases.Widget","title":"<code>magicgui.widgets.bases.Widget</code>","text":"<p>Basic Widget, wrapping a class that implements WidgetProtocol.</p> <p>Parameters:</p> <ul> <li> widget_type             (<code>type[WidgetProtocol]</code>)         \u2013          <p>A class implementing a widget protocol.  Will be instantiated during init.</p> </li> <li> name             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The name of the parameter represented by this widget. by default \"\"</p> </li> <li> annotation             (<code>Any</code>, default:                 <code>None</code> )         \u2013          <p>The type annotation for the parameter represented by the widget, by default <code>None</code></p> </li> <li> label             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>A string to use for an associated Label widget (if this widget is being shown in a <code>Container</code> widget, and labels are on). By default, <code>name</code> will be used. Note: <code>name</code> refers the name of the parameter, as might be used in a signature, whereas label is just the label for that widget in the GUI.</p> </li> <li> tooltip             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>A tooltip to display when hovering over the widget.</p> </li> <li> visible             (<code>bool</code>, default:                 <code>None</code> )         \u2013          <p>Whether the widget is visible, by default <code>True</code>.</p> </li> <li> enabled             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether the widget is enabled, by default <code>True</code>.</p> </li> <li> gui_only             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, widget is excluded from any function signature representation. by default <code>False</code>.  (This will likely be deprecated.)</p> </li> <li> parent             (<code>Any</code>, default:                 <code>None</code> )         \u2013          <p>Optional parent widget of this widget.  CAREFUL: if a parent is set, and subsequently deleted, this widget will likely be deleted as well (depending on the backend), and will no longer be usable.</p> </li> <li> backend_kwargs             (<code>dict</code>, default:                 <code>None</code> )         \u2013          <p>keyword argument to pass to the backend widget constructor.</p> </li> </ul>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.Widget.annotation","title":"<code>annotation: Any</code>  <code>property</code> <code>writable</code>","text":"<p>Return type annotation for the parameter represented by the widget.</p> <p>ForwardRefs will be resolve when setting the annotation.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.Widget.enabled","title":"<code>enabled: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Whether widget is enabled (editable).</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.Widget.height","title":"<code>height: int</code>  <code>property</code> <code>writable</code>","text":"<p>Return the current height of the widget.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.Widget.label","title":"<code>label: str</code>  <code>property</code> <code>writable</code>","text":"<p>Return a label to use for this widget when present in Containers.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.Widget.max_height","title":"<code>max_height: int</code>  <code>property</code> <code>writable</code>","text":"<p>Get the maximum height of the widget.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.Widget.max_width","title":"<code>max_width: int</code>  <code>property</code> <code>writable</code>","text":"<p>Get the maximum width of the widget.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.Widget.min_height","title":"<code>min_height: int</code>  <code>property</code> <code>writable</code>","text":"<p>Get the minimum height of the widget.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.Widget.min_width","title":"<code>min_width: int</code>  <code>property</code> <code>writable</code>","text":"<p>Get the minimum width of the widget.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.Widget.native","title":"<code>native: Any</code>  <code>property</code>","text":"<p>Return native backend widget.</p> <p>Note this is the widget that contains the layout, and not any parent widgets of this (e.g. a parent widget that is used to enable scroll bars)</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.Widget.options","title":"<code>options: dict</code>  <code>property</code>","text":"<p>Return options currently being used in this widget.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.Widget.param_kind","title":"<code>param_kind: inspect._ParameterKind</code>  <code>property</code> <code>writable</code>","text":"<p>Return :attr:<code>inspect.Parameter.kind</code> represented by this widget.</p> <p>Used in building signatures from multiple widgets, by default :attr:<code>~inspect.Parameter.POSITIONAL_OR_KEYWORD</code></p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.Widget.parent","title":"<code>parent: Widget</code>  <code>property</code> <code>writable</code>","text":"<p>Return the parent widget.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.Widget.root_native_widget","title":"<code>root_native_widget: Any</code>  <code>property</code>","text":"<p>Return the root native backend widget.</p> <p>This can be different from the <code>.native</code> widget if the layout is a child of some other widget, e.g. a widget used to enable scroll bars.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.Widget.tooltip","title":"<code>tooltip: str | None</code>  <code>property</code> <code>writable</code>","text":"<p>Get the tooltip for this widget.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.Widget.visible","title":"<code>visible: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Return whether widget is visible.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.Widget.widget_type","title":"<code>widget_type: str</code>  <code>property</code>","text":"<p>Return type of widget.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.Widget.width","title":"<code>width: int</code>  <code>property</code> <code>writable</code>","text":"<p>Return the current width of the widget.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.Widget.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Return representation of widget of instance.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.Widget.close","title":"<code>close() -&gt; None</code>","text":"<p>Close widget.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.Widget.hide","title":"<code>hide() -&gt; None</code>","text":"<p>Hide widget.</p> <p>alias for <code>widget.visible = False</code></p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.Widget.render","title":"<code>render() -&gt; np.ndarray</code>","text":"<p>Return an RGBA (MxNx4) numpy array bitmap of the rendered widget.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.Widget.show","title":"<code>show(run: bool = False) -&gt; Widget</code>","text":"<p>Show widget.</p> <p>alias for <code>widget.visible = True</code></p> <p>Parameters:</p> <ul> <li> run             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to start the application event loop, by default False</p> </li> </ul>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.Widget.shown","title":"<code>shown() -&gt; Iterator[Application]</code>","text":"<p>Context manager to show the widget.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.ButtonWidget","title":"<code>magicgui.widgets.bases.ButtonWidget</code>","text":"<p>             Bases: <code>ValueWidget[bool]</code></p> <p>Widget with a value, Wraps a widget implementing the ButtonWidgetProtocol.</p> <p>see ButtonWidgetProtocol.</p> <p>Parameters:</p> <ul> <li> value             (<code>bool</code>, default:                 <code>Undefined</code> )         \u2013          <p>The starting state of the widget.</p> </li> <li> text             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>The text to display on the button. If not provided, will use <code>name</code>.</p> </li> <li> bind             (<code>Callable[[ValueWidget], Any] | Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>A value or callback to bind this widget. If provided, whenever <code>widget.value</code> is accessed, the value provided here will be returned instead. <code>bind</code> may be a callable, in which case <code>bind(self)</code> will be returned (i.e. your bound callback must accept a single parameter, which is this widget instance).</p> </li> <li> nullable             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, the widget will accepts <code>None</code> as a valid value, by default <code>False</code>.</p> </li> <li> **base_widget_kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>All additional keyword arguments are passed to the base <code>magicgui.widgets.Widget</code> constructor.</p> </li> </ul>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.ButtonWidget.clicked","title":"<code>clicked: SignalInstance</code>  <code>property</code>","text":"<p>Alias for changed event.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.ButtonWidget.options","title":"<code>options: dict</code>  <code>property</code>","text":"<p>Return options currently being used in this widget.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.ButtonWidget.text","title":"<code>text: str</code>  <code>property</code> <code>writable</code>","text":"<p>Text of the widget.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.CategoricalWidget","title":"<code>magicgui.widgets.bases.CategoricalWidget</code>","text":"<p>             Bases: <code>ValueWidget[T]</code></p> <p>Widget with a value and choices.  Wraps CategoricalWidgetProtocol.</p> <p>Parameters:</p> <ul> <li> value             (<code>Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>The initially selected choice.</p> </li> <li> choices             (<code>Enum, Iterable, or Callable</code>, default:                 <code>()</code> )         \u2013          <p>Available choices displayed in the combo box.</p> </li> <li> bind             (<code>Callable[[ValueWidget], Any] | Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>A value or callback to bind this widget. If provided, whenever <code>widget.value</code> is accessed, the value provided here will be returned instead. <code>bind</code> may be a callable, in which case <code>bind(self)</code> will be returned (i.e. your bound callback must accept a single parameter, which is this widget instance).</p> </li> <li> nullable             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, the widget will accepts <code>None</code> as a valid value, by default <code>False</code>.</p> </li> <li> **base_widget_kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>All additional keyword arguments are passed to the base <code>magicgui.widgets.Widget</code> constructor.</p> </li> </ul>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.CategoricalWidget.choices","title":"<code>choices: tuple[T | None, ...]</code>  <code>property</code> <code>writable</code>","text":"<p>Available value choices for this widget.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.CategoricalWidget.current_choice","title":"<code>current_choice: str</code>  <code>property</code>","text":"<p>Return the text of the currently selected choice.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.CategoricalWidget.options","title":"<code>options: dict</code>  <code>property</code>","text":"<p>Return options currently being used in this widget.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.CategoricalWidget.value","title":"<code>value: T</code>  <code>property</code> <code>writable</code>","text":"<p>Return current value of the widget.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.CategoricalWidget.__len__","title":"<code>__len__() -&gt; int</code>","text":"<p>Return the number of choices.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.CategoricalWidget.del_choice","title":"<code>del_choice(choice_name: str) -&gt; None</code>","text":"<p>Delete the provided <code>choice_name</code> and associated data.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.CategoricalWidget.get_choice","title":"<code>get_choice(choice_name: str) -&gt; T</code>","text":"<p>Get data for the provided <code>choice_name</code>.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.CategoricalWidget.reset_choices","title":"<code>reset_choices(*_: Any) -&gt; None</code>","text":"<p>Reset choices to the default state.</p> <p>If self._default_choices is a callable, this may NOT be the exact same set of choices as when the widget was instantiated, if the callable relies on external state.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.CategoricalWidget.set_choice","title":"<code>set_choice(choice_name: str, data: Any | None = None) -&gt; None</code>","text":"<p>Set data for the provided <code>choice_name</code>.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.ContainerWidget","title":"<code>magicgui.widgets.bases.ContainerWidget</code>","text":"<p>             Bases: <code>Widget</code>, <code>_OrientationMixin</code>, <code>MutableSequence[WidgetVar]</code></p> <p>Widget that can contain other widgets.</p> <p>Wraps a widget that implements <code>ContainerProtocol</code>.</p> <p>A <code>ContainerWidget</code> behaves like a python list of Widget objects. Subwidgets can be accessed using integer or slice-based indexing (<code>container[0]</code>), as well as by widget name (<code>container.&lt;widget_name&gt;</code>). Widgets can be added with <code>append</code> or <code>insert</code>, and removed with <code>del</code> or <code>pop</code>, etc...</p> <p>There is a tight connection between a <code>ContainerWidget</code> and an inspect.Signature object, just as there is a tight connection between individual Widget<code>objects an an :class:</code>inspect.Parameter object. The signature representation of a <code>ContainerWidget</code> (with the current settings as default values) is accessible with the :meth:<code>~ContainerWidget.__signature__</code> method (or by using :func:<code>inspect.signature</code> from the standard library)</p> <p>For a <code>ContainerWidget</code> subclass that is tightly coupled to a specific function signature (as in the \"classic\" magicgui decorator), see magicgui.widgets.FunctionGui.</p> <p>Parameters:</p> <ul> <li> widgets             (<code>Sequence[Widget]</code>, default:                 <code>()</code> )         \u2013          <p>A sequence of widgets with which to initialize the container, by default <code>None</code>.</p> </li> <li> layout             (<code>str</code>, default:                 <code>'vertical'</code> )         \u2013          <p>The layout for the container.  must be one of <code>{'horizontal', 'vertical'}</code>. by default \"vertical\"</p> </li> <li> scrollable             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether to enable scroll bars or not. If enabled, scroll bars will only appear along the layout direction, not in both directions.</p> </li> <li> labels             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether each widget should be shown with a corresponding Label widget to the left, by default <code>True</code>.  Note: the text for each widget defaults to <code>widget.name</code>, but can be overridden by setting <code>widget.label</code>.</p> </li> <li> **base_widget_kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>All additional keyword arguments are passed to the base <code>magicgui.widgets.Widget</code> constructor.</p> </li> </ul>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.ContainerWidget.__signature__","title":"<code>__signature__: MagicSignature</code>  <code>property</code>","text":"<p>Return a MagicSignature object representing the current state of the gui.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.ContainerWidget.labels","title":"<code>labels: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Whether widgets are presented with labels.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.ContainerWidget.layout","title":"<code>layout: str</code>  <code>property</code> <code>writable</code>","text":"<p>Return the layout of the widget.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.ContainerWidget.margins","title":"<code>margins: tuple[int, int, int, int]</code>  <code>property</code> <code>writable</code>","text":"<p>Return margin between the content and edges of the container.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.ContainerWidget.__delattr__","title":"<code>__delattr__(name: str) -&gt; None</code>","text":"<p>Delete a widget by name.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.ContainerWidget.__delitem__","title":"<code>__delitem__(key: int | slice) -&gt; None</code>","text":"<p>Delete a widget by integer or slice index.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.ContainerWidget.__dir__","title":"<code>__dir__() -&gt; list[str]</code>","text":"<p>Add subwidget names to the dir() call for this widget.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.ContainerWidget.__getattr__","title":"<code>__getattr__(name: str) -&gt; WidgetVar</code>","text":"<p>Return attribute <code>name</code>.  Will return a widget if present.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.ContainerWidget.__getitem__","title":"<code>__getitem__(key: int | str | slice) -&gt; WidgetVar | MutableSequence[WidgetVar]</code>","text":"<p>Get item by integer, str, or slice.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.ContainerWidget.__len__","title":"<code>__len__() -&gt; int</code>","text":"<p>Return the count of widgets.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.ContainerWidget.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Return a repr.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.ContainerWidget.__setattr__","title":"<code>__setattr__(name: str, value: Any) -&gt; None</code>","text":"<p>Set attribute <code>name</code>.  Prevents changing widget if present, (use del).</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.ContainerWidget.__setitem__","title":"<code>__setitem__(key: Any, value: Any) -&gt; NoReturn</code>","text":"<p>Prevent assignment by index.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.ContainerWidget.asdict","title":"<code>asdict() -&gt; dict[str, Any]</code>","text":"<p>Return state of widget as dict.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.ContainerWidget.from_callable","title":"<code>from_callable(obj: Callable, gui_options: dict | None = None, **kwargs: Unpack[ContainerKwargs]) -&gt; Container</code>  <code>classmethod</code>","text":"<p>Create a Container widget from a callable object.</p> <p>In most cases, it will be preferable to create a <code>FunctionGui</code> instead.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.ContainerWidget.from_signature","title":"<code>from_signature(sig: inspect.Signature, **kwargs: Unpack[ContainerKwargs]) -&gt; Container</code>  <code>classmethod</code>","text":"<p>Create a Container widget from an inspect.Signature object.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.ContainerWidget.index","title":"<code>index(value: Any, start: int = 0, stop: int = 9223372036854775807) -&gt; int</code>","text":"<p>Return index of a specific widget instance (or widget name).</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.ContainerWidget.insert","title":"<code>insert(key: int, widget: WidgetVar) -&gt; None</code>","text":"<p>Insert widget at <code>key</code>.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.ContainerWidget.remove","title":"<code>remove(value: Widget | str) -&gt; None</code>","text":"<p>Remove a widget instance (may also be string name of widget).</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.ContainerWidget.reset_choices","title":"<code>reset_choices(*_: Any) -&gt; None</code>","text":"<p>Reset choices for all Categorical subWidgets to the default state.</p> <p>If widget._default_choices is a callable, this may NOT be the exact same set of choices as when the widget was instantiated, if the callable relies on external state.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.ContainerWidget.update","title":"<code>update(mapping: Mapping | Iterable[tuple[str, Any]] | None = None, **kwargs: Any) -&gt; None</code>","text":"<p>Update the parameters in the widget from a mapping, iterable, or kwargs.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.DialogWidget","title":"<code>magicgui.widgets.bases.DialogWidget</code>","text":"<p>             Bases: <code>ContainerWidget</code></p> <p>Modal Container.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.DialogWidget.exec","title":"<code>exec() -&gt; bool</code>","text":"<p>Show the dialog, and block.</p> <p>Return True if the dialog was accepted, False if rejected.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.MainWindowWidget","title":"<code>magicgui.widgets.bases.MainWindowWidget</code>","text":"<p>             Bases: <code>ContainerWidget</code></p> <p>Top level Application widget that can contain other widgets.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.MainWindowWidget.create_menu_item","title":"<code>create_menu_item(menu_name: str, item_name: str, callback: Callable | None = None, shortcut: str | None = None) -&gt; None</code>","text":"<p>Create a menu item <code>item_name</code> under menu <code>menu_name</code>.</p> <p><code>menu_name</code> will be created if it does not already exist.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.RangedWidget","title":"<code>magicgui.widgets.bases.RangedWidget</code>","text":"<p>             Bases: <code>ValueWidget[T]</code></p> <p>Widget with a constrained value. Wraps RangedWidgetProtocol.</p> <p>Parameters:</p> <ul> <li> value             (<code>Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>The starting value for the widget.</p> </li> <li> min             (<code>float</code>, default:                 <code>Undefined</code> )         \u2013          <p>The minimum allowable value, by default 0 (or <code>value</code> if <code>value</code> is less than 0)</p> </li> <li> max             (<code>float</code>, default:                 <code>Undefined</code> )         \u2013          <p>The maximum allowable value, by default 999 (or <code>value</code> if <code>value</code> is greater than 999)</p> </li> <li> step             (<code>float</code>, default:                 <code>Undefined</code> )         \u2013          <p>The step size for incrementing the value, by default adaptive step is used</p> </li> <li> bind             (<code>Callable[[ValueWidget], Any] | Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>A value or callback to bind this widget. If provided, whenever <code>widget.value</code> is accessed, the value provided here will be returned instead. <code>bind</code> may be a callable, in which case <code>bind(self)</code> will be returned (i.e. your bound callback must accept a single parameter, which is this widget instance).</p> </li> <li> nullable             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, the widget will accepts <code>None</code> as a valid value, by default <code>False</code>.</p> </li> <li> **base_widget_kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>All additional keyword arguments are passed to the base <code>magicgui.widgets.Widget</code> constructor.</p> </li> </ul>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.RangedWidget.adaptive_step","title":"<code>adaptive_step: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Whether the step size is adaptive.</p> <p>Adaptive decimal step means that the step size will continuously be adjusted to one power of ten below the current value. So when the value is 1100, the step is set to 100, so stepping up once increases it to 1200. For 1200 stepping up takes it to 1300. For negative values, stepping down from -1100 goes to -1200.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.RangedWidget.max","title":"<code>max: float</code>  <code>property</code> <code>writable</code>","text":"<p>Maximum allowable value for the widget.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.RangedWidget.min","title":"<code>min: float</code>  <code>property</code> <code>writable</code>","text":"<p>Minimum allowable value for the widget.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.RangedWidget.options","title":"<code>options: dict</code>  <code>property</code>","text":"<p>Return options currently being used in this widget.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.RangedWidget.range","title":"<code>range: tuple[float, float]</code>  <code>property</code> <code>writable</code>","text":"<p>Range of allowable values for the widget.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.RangedWidget.step","title":"<code>step: float | None</code>  <code>property</code> <code>writable</code>","text":"<p>Step size for widget values (None if adaptive step is turned on).</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.RangedWidget.value","title":"<code>value(value: T) -&gt; None</code>","text":"<p>Set widget value, will raise Value error if not within min/max.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.SliderWidget","title":"<code>magicgui.widgets.bases.SliderWidget</code>","text":"<p>             Bases: <code>RangedWidget[T]</code>, <code>_OrientationMixin</code></p> <p>Widget with a constrained value and orientation. Wraps SliderWidgetProtocol.</p> <p>Parameters:</p> <ul> <li> value             (<code>Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>The starting value for the widget.</p> </li> <li> min             (<code>float</code>, default:                 <code>Undefined</code> )         \u2013          <p>The minimum allowable value, by default 0 (or <code>value</code> if <code>value</code> is less than 0)</p> </li> <li> max             (<code>float</code>, default:                 <code>Undefined</code> )         \u2013          <p>The maximum allowable value, by default 999 (or <code>value</code> if <code>value</code> is greater than 999)</p> </li> <li> step             (<code>float</code>, default:                 <code>Undefined</code> )         \u2013          <p>The step size for incrementing the value, by default adaptive step is used</p> </li> <li> orientation             (<code>(str, {'horizontal', 'vertical'})</code>, default:                 <code>'horizontal'</code> )         \u2013          <p>The orientation for the slider, by default \"horizontal\"</p> </li> <li> readout             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Whether to show the editable spinbox next to the slider</p> </li> <li> tracking             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>If tracking is enabled (the default), the slider emits the <code>changed</code> signal while the slider is being dragged. If tracking is disabled, the slider emits the <code>changed</code> signal only after the user releases the slider.</p> </li> <li> bind             (<code>Callable[[ValueWidget], Any] | Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>A value or callback to bind this widget. If provided, whenever <code>widget.value</code> is accessed, the value provided here will be returned instead. <code>bind</code> may be a callable, in which case <code>bind(self)</code> will be returned (i.e. your bound callback must accept a single parameter, which is this widget instance).</p> </li> <li> nullable             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, the widget will accepts <code>None</code> as a valid value, by default <code>False</code>.</p> </li> <li> **base_widget_kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>All additional keyword arguments are passed to the base <code>magicgui.widgets.Widget</code> constructor.</p> </li> </ul>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.SliderWidget.options","title":"<code>options: dict</code>  <code>property</code>","text":"<p>Return options currently being used in this widget.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.SliderWidget.readout","title":"<code>readout: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Get visibility state of readout widget.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.SliderWidget.tracking","title":"<code>tracking: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Return whether slider tracking is enabled.</p> <p>If tracking is enabled (the default), the slider emits the changed() signal while the slider is being dragged. If tracking is disabled, the slider emits the changed() signal only when the user releases the slider.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.ValueWidget","title":"<code>magicgui.widgets.bases.ValueWidget</code>","text":"<p>             Bases: <code>Widget</code>, <code>Generic[T]</code></p> <p>Widget with a value, Wraps ValueWidgetProtocol.</p> <p>Parameters:</p> <ul> <li> value             (<code>Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>The starting value for the widget.</p> </li> <li> bind             (<code>Callable[[ValueWidget], Any] | Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>A value or callback to bind this widget. If provided, whenever <code>widget.value</code> is accessed, the value provided here will be returned instead. <code>bind</code> may be a callable, in which case <code>bind(self)</code> will be returned (i.e. your bound callback must accept a single parameter, which is this widget instance).</p> </li> <li> nullable             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>If <code>True</code>, the widget will accepts <code>None</code> as a valid value, by default <code>False</code>.</p> </li> <li> **base_widget_kwargs             (<code>Any</code>, default:                 <code>{}</code> )         \u2013          <p>All additional keyword arguments are passed to the base <code>magicgui.widgets.Widget</code> constructor.</p> </li> </ul>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.ValueWidget.annotation","title":"<code>annotation: Any</code>  <code>property</code> <code>writable</code>","text":"<p>Return type annotation for the parameter represented by the widget.</p> <p>ForwardRefs will be resolve when setting the annotation. If the widget is nullable (had a type annototation of Optional[Type]), annotation will return the first argument in the Optional clause.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.ValueWidget.value","title":"<code>value: T</code>  <code>property</code> <code>writable</code>","text":"<p>Return current value of the widget.  This may be interpreted by backends.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.ValueWidget.__repr__","title":"<code>__repr__() -&gt; str</code>","text":"<p>Return representation of widget of instance.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.ValueWidget.bind","title":"<code>bind(value: T | Callable[[ValueWidget], T], call: bool = True) -&gt; None</code>","text":"<p>Binds <code>value</code> to self.value.</p> <p>If a value is bound to this widget, then whenever <code>widget.value</code> is accessed, the value provided here will be returned.  <code>value</code> can be a callable, in which case <code>value(self)</code> will be returned (i.e. your callback must accept a single parameter, which is this widget instance.).</p> <p>If you provide a callable and you don't want it to be called (but rather just returned as a callable object, then use <code>call=False</code> when binding your value.</p> <p>Note: if you need to access the \"original\" <code>widget.value</code> within your callback, please use <code>widget.get_value()</code> instead of the <code>widget.value</code> property, in order to avoid a RuntimeError.</p> <p>Parameters:</p> <ul> <li> value             (<code>Any</code>)         \u2013          <p>The value (or callback) to return when accessing this widget's value.</p> </li> <li> call             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>If <code>value</code> is a callable and <code>call</code> is <code>True</code>, the callback will be called as <code>callback(self)</code> when accessing <code>self.value</code>.  If <code>False</code>, the callback will simply be returned as a callable object, by default, <code>True</code>.</p> </li> </ul>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.ValueWidget.get_value","title":"<code>get_value() -&gt; T</code>","text":"<p>Callable version of <code>self.value</code>.</p> <p>The main API is to use <code>self.value</code>, however, this is here in order to provide an escape hatch if trying to access the widget's value inside of a callback bound to self._bound_value.</p>"},{"location":"api/widgets/bases/#magicgui.widgets.bases.ValueWidget.unbind","title":"<code>unbind() -&gt; None</code>","text":"<p>Unbinds any bound values. (see <code>ValueWidget.bind</code>).</p>"},{"location":"api/widgets/create_widget/","title":"<code>magicgui.widgets.create_widget</code>","text":""},{"location":"api/widgets/create_widget/#magicgui.widgets.create_widget","title":"<code>magicgui.widgets.create_widget(value=Undefined, annotation=None, name='', param_kind='POSITIONAL_OR_KEYWORD', label=None, gui_only=False, app=None, widget_type=None, options=None, is_result=False, raise_on_unknown=True)</code>","text":"<p>Create and return appropriate widget subclass.</p> <p>This factory function can be used to create a widget appropriate for the provided <code>value</code> and/or <code>annotation</code> provided. See Type Mapping Docs for details on how the widget type is determined from type annotations.</p> <p>Parameters:</p> <ul> <li> value             (<code>Any</code>, default:                 <code>Undefined</code> )         \u2013          <p>The starting value for the widget, by default <code>None</code></p> </li> <li> annotation             (<code>Any</code>, default:                 <code>None</code> )         \u2013          <p>The type annotation for the parameter represented by the widget, by default <code>None</code>.</p> </li> <li> name             (<code>str</code>, default:                 <code>''</code> )         \u2013          <p>The name of the parameter represented by this widget. by default <code>\"\"</code></p> </li> <li> param_kind             (<code>str</code>, default:                 <code>'POSITIONAL_OR_KEYWORD'</code> )         \u2013          <p>The :attr:<code>inspect.Parameter.kind</code> represented by this widget.  Used in building signatures from multiple widgets, by default \"<code>POSITIONAL_OR_KEYWORD</code>\"</p> </li> <li> label             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>A string to use for an associated Label widget (if this widget is being shown in a <code>Container</code> widget, and labels are on). By default, <code>name</code> will be used. Note: <code>name</code> refers the name of the parameter, as might be used in a signature, whereas label is just the label for that widget in the GUI.</p> </li> <li> gui_only             (<code>bool</code>, default:                 <code>False</code> )         \u2013          <p>Whether the widget should be considered \"only for the gui\", or if it should be included in any widget container signatures, by default False</p> </li> <li> app             (<code>str</code>, default:                 <code>None</code> )         \u2013          <p>The backend to use, by default <code>None</code></p> </li> <li> widget_type             (<code>str or Type[WidgetProtocol] or None</code>, default:                 <code>None</code> )         \u2013          <p>A class implementing a widget protocol or a string with the name of a magicgui widget type (e.g. \"Label\", \"PushButton\", etc...). If provided, this widget type will be used instead of the type autodetermined from <code>value</code> and/or <code>annotation</code> above.</p> </li> <li> options             (<code>dict</code>, default:                 <code>None</code> )         \u2013          <p>Dict of options to pass to the Widget constructor, by default dict()</p> </li> <li> is_result             (<code>boolean</code>, default:                 <code>False</code> )         \u2013          <p>Whether the widget belongs to an input or an output. By default, an input is assumed.</p> </li> <li> raise_on_unknown             (<code>bool</code>, default:                 <code>True</code> )         \u2013          <p>Raise exception if no widget is found for the given type, by default True</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Widget</code>         \u2013          <p>An instantiated widget subclass</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>           \u2013          <p>If the provided or autodetected <code>widget_type</code> does not implement any known widget protocols</p> </li> </ul> <p>Examples:</p> <pre><code>from magicgui.widgets import create_widget\n\n# create a widget from a string value\nwdg = create_widget(value=\"hello world\")\nassert wdg.value == \"hello world\"\n\n# create a widget from a string annotation\nwdg = create_widget(annotation=str)\nassert wdg.value == \"\"\n</code></pre>"},{"location":"generated_examples/","title":"Examples","text":""},{"location":"generated_examples/#getting-started","title":"Getting started","text":"<p>A gallery of examples for magicgui.</p> <p> Basic example </p> <p> Basic widgets demo </p>"},{"location":"generated_examples/#demo-applications","title":"Demo applications","text":"<p>Example applications built with magicgui.</p> <p> Input values dialog </p> <p> Quantities with pint </p> <p> Callable functions demo </p> <p> Snell's law demonstration using magicgui </p> <p> Hotdog or not app </p> <p> Chaining functions together </p>"},{"location":"generated_examples/#demo-widget-types","title":"Demo widget types","text":"<p>Example gallery demonstrating the available widget types in magicgui.</p> <p> Image widget </p> <p> Custom text labels for widgets </p> <p> Range slider widget </p> <p> Log slider widget </p> <p> Optional user choice </p> <p> Multiple selection widget </p> <p> Password login </p> <p> File dialog widget </p> <p> Dropdown selection widget </p> <p> Table widget </p>"},{"location":"generated_examples/#matplotlib-and-magicgui","title":"matplotlib and magicgui","text":"<p>Examples involving matplotlib graphs and magicgui.</p> <p> matplotlib figure example </p> <p> Waveforms example </p>"},{"location":"generated_examples/#napari-and-magicgui","title":"napari and magicgui","text":"<p>Examples integrating magicgui with napari.</p> <p> napari forward reference demo </p> <p> napari Qt demo </p> <p> napari parameter sweeps </p> <p> napari image arithmetic widget </p>"},{"location":"generated_examples/#jupyter-notebooks-and-magicgui","title":"Jupyter notebooks and magicgui","text":"<p>Examples using jupyter notebooks together with magicgui.</p> <p> Jupyter notebooks and magicgui </p>"},{"location":"generated_examples/#progress-bar-examples","title":"Progress bar examples","text":"<p>Examples of progress bars in magicgui.</p> <p> Manual progress bar </p> <p> Simple progress bar </p> <p> Indeterminate progress bar </p> <p> Nested progress bars </p>"},{"location":"generated_examples/#under-the-hood","title":"Under the hood","text":"<p>Learn more advanced usage patterns for magicgui, including self referencing widgets and decorating class methods with magicgui.</p> <p> Self reference magicgui widgets </p> <p> Deocrate class methods with magicgui </p> <p> Download all examples in Python source code: generated_examples_python.zip</p> <p> Download all examples in Jupyter notebooks: generated_examples_jupyter.zip</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated_examples/basic_example/","title":"Basic example","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated_examples/basic_example/#basic-example","title":"Basic example","text":"<p>A basic example using magicgui.</p> <p></p> <p>Out:</p> <pre><code>&lt;FunctionGui example(x: int = 0, y='hi')&gt;\n</code></pre> <p></p> <pre><code>from magicgui import magicgui\n\n\n@magicgui\ndef example(x: int, y=\"hi\"):\n    \"\"\"Basic example function.\"\"\"\n    return x, y\n\n\nexample.changed.connect(print)\nexample.show(run=True)\n</code></pre> <p>Total running time of the script: ( 0 minutes  2.067 seconds)</p> <p> Download Python source code: basic_example.py</p> <p> Download Jupyter notebook: basic_example.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated_examples/basic_widgets_demo/","title":"Basic widgets demo","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated_examples/basic_widgets_demo/#basic-widgets-demo","title":"Basic widgets demo","text":"<p>Widget demonstration with magicgui.</p> <p>This code demonstrates a few of the widget types that magicgui can create based on the parameter types in your function.</p> <p></p> <p>Out:</p> <pre><code>&lt;MainFunctionGui widget_demo(boolean=True, integer=1, spin_float=3.14, slider_float=43.5, slider_int=550, string='Text goes here', dropdown=&lt;Medium.Glass: 1.52&gt;, radio_option=2, date=datetime.date(1999, 12, 31), time=datetime.time(1, 30, 20), datetime=datetime.datetime(2023, 10, 23, 15, 28, 32, 329000), filename=PosixPath('/Users/runner'))&gt;\n</code></pre> <p></p> <pre><code>import datetime\nfrom enum import Enum\nfrom pathlib import Path\n\nfrom magicgui import magicgui\n\n\nclass Medium(Enum):\n    \"\"\"Enum for various media and their refractive indices.\"\"\"\n\n    Glass = 1.520\n    Oil = 1.515\n    Water = 1.333\n    Air = 1.0003\n\n\n@magicgui(\n    main_window=True,\n    call_button=\"Calculate\",\n    layout=\"vertical\",\n    result_widget=True,\n    slider_float={\"widget_type\": \"FloatSlider\", \"max\": 100},\n    slider_int={\"widget_type\": \"Slider\", \"readout\": False},\n    radio_option={\n        \"widget_type\": \"RadioButtons\",\n        \"orientation\": \"horizontal\",\n        \"choices\": [(\"first option\", 1), (\"second option\", 2)],\n    },\n    filename={\"label\": \"Pick a file:\"},\n)\ndef widget_demo(\n    boolean=True,\n    integer=1,\n    spin_float=3.14159,\n    slider_float=43.5,\n    slider_int=550,\n    string=\"Text goes here\",\n    dropdown=Medium.Glass,\n    radio_option=2,\n    date=datetime.date(1999, 12, 31),\n    time=datetime.time(1, 30, 20),\n    datetime=datetime.datetime.now(),\n    filename=Path.home(),\n):\n    \"\"\"We can use numpy docstrings to provide tooltips.\n\n    Parameters\n    ----------\n    boolean : bool, optional\n        A checkbox for booleans, by default True\n    integer : int, optional\n        Some integer, by default 1\n    spin_float : float, optional\n        This one is a float, by default \"pi\"\n    slider_float : float, optional\n        Hey look! I'm a slider, by default 43.5\n    slider_int : float, optional\n        I only take integers, and I've hidden my readout, by default 550\n    string : str, optional\n        We'll use this string carefully, by default \"Text goes here\"\n    dropdown : Enum, optional\n        Pick a medium, by default Medium.Glass\n    radio_option : int\n        A set of radio buttons.\n    date : datetime.date, optional\n        Your birthday, by default datetime.date(1999, 12, 31)\n    time : datetime.time, optional\n        Some time, by default datetime.time(1, 30, 20)\n    datetime : datetime.datetime, optional\n        A very specific time and date, by default ``datetime.datetime.now()``\n    filename : str, optional\n        Pick a path, by default Path.home()\n    \"\"\"\n    return locals().values()\n\n\nwidget_demo.changed.connect(print)\nwidget_demo.show(run=True)\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.207 seconds)</p> <p> Download Python source code: basic_widgets_demo.py</p> <p> Download Jupyter notebook: basic_widgets_demo.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated_examples/mg_execution_times/","title":"Computation times","text":"<p>00:02.274 total execution time for generated_examples files:</p> <p>+-------------------------------------------------------------------------------------+-----------+--------+ | basic_example (docs/examples/basic_example.py)                | 00:02.067 | 0.0 MB | +-------------------------------------------------------------------------------------+-----------+--------+ | basic_widgets_demo (docs/examples/basic_widgets_demo.py) | 00:00.207 | 0.0 MB | +-------------------------------------------------------------------------------------+-----------+--------+</p>"},{"location":"generated_examples/applications/callable/","title":"Callable functions demo","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated_examples/applications/callable/#callable-functions-demo","title":"Callable functions demo","text":"<p>This example demonstrates handling callable functions with magicgui.</p> <p></p> <p>Out:</p> <pre><code>&lt;FunctionGui example(func='f')&gt;\n</code></pre> <p></p> <pre><code>from magicgui import magicgui\n\n\ndef f(x: int, y=\"a string\") -&gt; str:\n    \"\"\"Example function F.\"\"\"\n    return f\"{y} {x}\"\n\n\ndef g(x: int = 6, y=\"another string\") -&gt; str:\n    \"\"\"Example function G.\"\"\"\n    return f\"{y} asdfsdf {x}\"\n\n\n@magicgui(call_button=True, func={\"choices\": [\"f\", \"g\"]})\ndef example(func=\"f\"):\n    \"\"\"\u00cbxample function.\"\"\"\n    pass\n\n\ndef update(f: str):\n    \"\"\"Update function.\"\"\"\n    if len(example) &gt; 2:\n        del example[1]\n    example.insert(1, magicgui(globals()[f]))\n\n\nexample.func.changed.connect(update)\nexample.show(run=True)\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.063 seconds)</p> <p> Download Python source code: callable.py</p> <p> Download Jupyter notebook: callable.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated_examples/applications/chaining/","title":"Chaining functions together","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated_examples/applications/chaining/#chaining-functions-together","title":"Chaining functions together","text":"<p>This example demonstrates chaining multiple functions together.</p> <p></p> <p>Out:</p> <pre><code>calling func_a\ncalling func_b\ncalling func_c\n\n\n&lt;Container (func_a: NoneType, func_b: NoneType, func_c: NoneType)&gt;\n</code></pre> <p></p> <pre><code>from magicgui import magicgui, widgets\n\n\n@magicgui(auto_call=True)\ndef func_a(x: int = 64, y: int = 64):\n    \"\"\"Callable function A.\"\"\"\n    print(\"calling func_a\")\n    return x + y\n\n\n@magicgui(auto_call=True, input={\"visible\": False, \"label\": \" \", \"max\": 100000})\ndef func_b(input: int, mult=1.0):\n    \"\"\"Callable function B.\"\"\"\n    print(\"calling func_b\")\n    result = input * mult\n    # since these function defs live in globals(), you can update them directly\n    func_c.input.value = result\n    return result\n\n\n# alternatively, you can the `widget.called` signal to connect a callback function\n# where the result of the function being called is at `value`\n@func_a.called.connect\ndef _on_func_a(value: str):\n    func_b.input.value = value\n\n\n@magicgui(\n    auto_call=True,\n    input={\"visible\": False, \"max\": 100000},\n    result_widget=True,\n    labels=False,\n)\ndef func_c(input: int, format: str = \"({} + {}) * {} is {}\") -&gt; str:\n    \"\"\"Callable function C.\"\"\"\n    print(\"calling func_c\\n\")\n    return format.format(func_a.x.value, func_a.y.value, func_b.mult.value, input)\n\n\ncontainer = widgets.Container(\n    widgets=[func_a, func_b, func_c], layout=\"vertical\", labels=False\n)\ncontainer.native.setMinimumWidth(500)\nfunc_a()\ncontainer.show(run=True)\n\n# notice which functions get called when you change each widget.\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.092 seconds)</p> <p> Download Python source code: chaining.py</p> <p> Download Jupyter notebook: chaining.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated_examples/applications/hotdog/","title":"Hotdog or not app","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated_examples/applications/hotdog/#hotdog-or-not-app","title":"Hotdog or not app","text":"<p>Demo app to upload an image and classify if it's an hotdog or not.</p> <p></p> <pre><code>import pathlib\nfrom enum import Enum\n\nfrom magicgui import magicgui\n\n\nclass HotdogOptions(Enum):\n    \"\"\"All hotdog possibilities.\"\"\"\n\n    Hotdog = 1\n    NotHotdog = 0\n\n\n@magicgui(main_window=True, layout=\"form\", call_button=\"Classify\", result_widget=True)\ndef is_hotdog(img: pathlib.Path) -&gt; HotdogOptions:\n    \"\"\"Classify possible hotdog images.\n\n    Upload an image and check whether it's an hotdog. For example, this image\n    will be classified as one: &lt;br&gt;&lt;br&gt;\n\n    &lt;img src=\"resources/hotdog.jpg\"&gt;\n\n    Parameters\n    ----------\n    img : pathlib.Path\n        Path to a possible hotdog image\n\n    Returns\n    -------\n    HotdogOptions\n        True if image contains an hotdog in it\n    \"\"\"\n    if \"hotdog\" in img.stem:\n        return HotdogOptions.Hotdog\n    return HotdogOptions.NotHotdog\n\n\nif __name__ == \"__main__\":\n    is_hotdog.show(run=True)\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.076 seconds)</p> <p> Download Python source code: hotdog.py</p> <p> Download Jupyter notebook: hotdog.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated_examples/applications/mg_execution_times/","title":"Computation times","text":"<p>00:01.922 total execution time for generated_examples_applications files:</p> <p>+-----------------------------------------------------------------------------------+-----------+--------+ | pint_quantity (docs/examples/applications/pint_quantity.py) | 00:01.612 | 0.0 MB | +-----------------------------------------------------------------------------------+-----------+--------+ | chaining (docs/examples/applications/chaining.py)                | 00:00.092 | 0.0 MB | +-----------------------------------------------------------------------------------+-----------+--------+ | snells_law (docs/examples/applications/snells_law.py)          | 00:00.079 | 0.0 MB | +-----------------------------------------------------------------------------------+-----------+--------+ | hotdog (docs/examples/applications/hotdog.py)                      | 00:00.076 | 0.0 MB | +-----------------------------------------------------------------------------------+-----------+--------+ | callable (docs/examples/applications/callable.py)                | 00:00.063 | 0.0 MB | +-----------------------------------------------------------------------------------+-----------+--------+ | values_dialog (docs/examples/applications/values_dialog.py) | 00:00.000 | 0.0 MB | +-----------------------------------------------------------------------------------+-----------+--------+</p>"},{"location":"generated_examples/applications/pint_quantity/","title":"Quantities with pint","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated_examples/applications/pint_quantity/#quantities-with-pint","title":"Quantities with pint","text":"<p>Pint is a Python package to define, operate and manipulate physical quantities: the product of a numerical value and a unit of measurement. It allows arithmetic operations between them and conversions from and to different units. https://pint.readthedocs.io/en/stable/</p> <p></p> <p>Out:</p> <pre><code>&lt;FunctionGui widget(q=&lt;Quantity(1, 'millisecond')&gt;)&gt;\n</code></pre> <p></p> <pre><code>from pint import Quantity\n\nfrom magicgui import magicgui\n\n\n@magicgui\ndef widget(q=Quantity(\"1 ms\")):\n    \"\"\"Widget allowing users to input quantity measurements.\"\"\"\n    print(q)\n\n\nwidget.show(run=True)\n</code></pre> <p>Total running time of the script: ( 0 minutes  1.612 seconds)</p> <p> Download Python source code: pint_quantity.py</p> <p> Download Jupyter notebook: pint_quantity.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated_examples/applications/snells_law/","title":"Snell's law demonstration using magicgui","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated_examples/applications/snells_law/#snells-law-demonstration-using-magicgui","title":"Snell's law demonstration using magicgui","text":"<p>Demo app for calculating angles of refraction according to Snell's law.</p> <p></p> <p>Out:</p> <pre><code>&lt;FunctionGui snells_law(aoi=1.0, n1=&lt;Medium.Glass: 1.52&gt;, n2=&lt;Medium.Water: 1.333&gt;, degrees=True)&gt;\n</code></pre> <p></p> <pre><code>import math\nfrom enum import Enum\n\nfrom magicgui import magicgui\n\n\nclass Medium(Enum):\n    \"\"\"Enum for various media and their refractive indices.\"\"\"\n\n    Glass = 1.520\n    Oil = 1.515\n    Water = 1.333\n    Air = 1.0003\n\n\n@magicgui(call_button=\"calculate\", result_widget=True)\ndef snells_law(aoi=1.0, n1=Medium.Glass, n2=Medium.Water, degrees=True):\n    \"\"\"Calculate the angle of refraction given two media and an AOI.\"\"\"\n    if degrees:\n        aoi = math.radians(aoi)\n    try:\n        n1 = n1.value\n        n2 = n2.value\n        result = math.asin(n1 * math.sin(aoi) / n2)\n        return round(math.degrees(result) if degrees else result, 2)\n    except ValueError:  # math domain error\n        return \"TIR!\"\n\n\nsnells_law.show(run=True)\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.079 seconds)</p> <p> Download Python source code: snells_law.py</p> <p> Download Jupyter notebook: snells_law.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated_examples/applications/values_dialog/","title":"Input values dialog","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated_examples/applications/values_dialog/#input-values-dialog","title":"Input values dialog","text":"<p>A basic example of a user input dialog.</p> <p>This will pause code execution until the user responds.</p>"},{"location":"generated_examples/applications/values_dialog/#_1","title":"Input values dialog","text":"<pre><code>from magicgui.widgets import request_values\n\nvals = request_values(\n    age=int,\n    name={\"annotation\": str, \"label\": \"Enter your name:\"},\n    title=\"Hi, who are you?\",\n)\nprint(repr(vals))\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.000 seconds)</p> <p> Download Python source code: values_dialog.py</p> <p> Download Jupyter notebook: values_dialog.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated_examples/demo_widgets/change_label/","title":"Custom text labels for widgets","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated_examples/demo_widgets/change_label/#custom-text-labels-for-widgets","title":"Custom text labels for widgets","text":"<p>An example showing how to create custom text labels for your widgets.</p> <p></p> <p>Out:</p> <pre><code>&lt;FunctionGui example(x=1, y='hi')&gt;\n</code></pre> <p></p> <pre><code>from magicgui import magicgui\n\n\n# use a different label than the default (the parameter name) in the UI\n@magicgui(x={\"label\": \"widget to set x\"})\ndef example(x=1, y=\"hi\"):\n    \"\"\"Example function.\"\"\"\n    return x, y\n\n\nexample.changed.connect(print)\nexample.show(run=True)\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.064 seconds)</p> <p> Download Python source code: change_label.py</p> <p> Download Jupyter notebook: change_label.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated_examples/demo_widgets/choices/","title":"Dropdown selection widget","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated_examples/demo_widgets/choices/#dropdown-selection-widget","title":"Dropdown selection widget","text":"<p>Choices for dropdowns can be provided in a few different ways.</p> <p></p> <p>Out:</p> <pre><code>&lt;Container (as_list: NoneType, as_enum: NoneType, as_2tuple: NoneType, as_function: NoneType)&gt;\n</code></pre> <p></p> <pre><code>from enum import Enum\n\nfrom magicgui import magicgui, widgets\n\n\nclass Medium(Enum):\n    \"\"\"Enum for various media and their refractive indices.\"\"\"\n\n    Oil = 1.515\n    Water = 1.333\n    Air = 1.0003\n\n\n@magicgui(ri={\"choices\": [\"Oil\", \"Water\", \"Air\"]}, auto_call=True)\ndef as_list(ri=\"Water\"):\n    \"\"\"Function decorated with magicgui list of choices.\"\"\"\n    print(\"refractive index is\", Medium[ri].value)\n\n\n@magicgui(auto_call=True)\ndef as_enum(ri: Medium = Medium.Water):\n    \"\"\"Function decorated with magicgui and enumeration.\"\"\"\n    print(\"refractive index is\", ri.value)\n\n\n@magicgui(\n    ri={\"choices\": [(\"Oil\", 1.515), (\"Water\", 1.33), (\"Air\", 1.0)]}, auto_call=True\n)\ndef as_2tuple(ri=1.33):\n    \"\"\"Function decorated with magicgui tuple of choices.\"\"\"\n    print(\"refractive index is\", ri)\n\n\ndef get_choices(gui):\n    \"\"\"Function returning tuple of material and refractive index value.\"\"\"\n    return [(\"Oil\", 1.515), (\"Water\", 1.33), (\"Air\", 1.0)]\n\n\n@magicgui(ri={\"choices\": get_choices}, auto_call=True)\ndef as_function(ri: float):\n    \"\"\"Function to calculate refractive index.\"\"\"\n    print(\"refractive index is\", ri)\n\n\ncontainer = widgets.Container(\n    widgets=[as_list, as_enum, as_2tuple, as_function], layout=\"vertical\"\n)\ncontainer.show(run=True)\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.091 seconds)</p> <p> Download Python source code: choices.py</p> <p> Download Jupyter notebook: choices.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated_examples/demo_widgets/file_dialog/","title":"File dialog widget","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated_examples/demo_widgets/file_dialog/#file-dialog-widget","title":"File dialog widget","text":"<p>A file dialog widget example.</p> <ul> %s </ul> <pre><code>* ![file dialog](../images/mkd_glr_file_dialog_001.png){: .mkd-glr-multi-img srcset=\"../images/mkd_glr_file_dialog_001.png\"}\n\n* ![file dialog](../images/mkd_glr_file_dialog_002.png){: .mkd-glr-multi-img srcset=\"../images/mkd_glr_file_dialog_002.png\"}\n\n* ![file dialog](../images/mkd_glr_file_dialog_003.png){: .mkd-glr-multi-img srcset=\"../images/mkd_glr_file_dialog_003.png\"}\n</code></pre> <pre><code>from pathlib import Path\nfrom typing import Sequence\n\nfrom magicgui import magicgui, use_app\n\n\n@magicgui(filename={\"mode\": \"r\"})\ndef filepicker(filename=Path(\"~\")):\n    \"\"\"Take a filename and do something with it.\"\"\"\n    print(\"The filename is:\", filename)\n    return filename\n\n\n# Sequence of paths\n# We change the label using \"label\" for added clarity\n# the filter argument restricts file types\n@magicgui(filenames={\"label\": \"Choose Tiff files:\", \"filter\": \"*.tif\"})\ndef filespicker(filenames: Sequence[Path]):\n    \"\"\"Take a filename and do something with it.\"\"\"\n    print(\"The filenames are:\", filenames)\n    return filenames\n\n\n# Select a directory, instead of file(s)\n@magicgui(directory={\"mode\": \"d\", \"label\": \"Choose a directory\"})\ndef directorypicker(directory=Path(\"~\")):\n    \"\"\"Take a directory name and do something with it.\"\"\"\n    print(\"The directory name is:\", directory)\n    return directory\n\n\nfilepicker.show()\nfilespicker.show()\ndirectorypicker.show()\nfilepicker.filename.changed.connect(print)\nfilespicker.filenames.changed.connect(print)\ndirectorypicker.directory.changed.connect(print)\n\nuse_app().run()\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.128 seconds)</p> <p> Download Python source code: file_dialog.py</p> <p> Download Jupyter notebook: file_dialog.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated_examples/demo_widgets/image/","title":"Image widget","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated_examples/demo_widgets/image/#image-widget","title":"Image widget","text":"<p>Example of creating an Image Widget from a file.</p> <p>(This requires pillow, or that magicgui was installed as <code>magicgui[image]</code>)</p> <p></p> <p>Out:</p> <pre><code>Image(200x232x3, name='')\n</code></pre> <p></p> <pre><code>from magicgui.widgets import Image\n\nimage = Image(value=\"../../images/_test.jpg\")\nimage.scale_widget_to_image_size()\nimage.show(run=True)\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.046 seconds)</p> <p> Download Python source code: image.py</p> <p> Download Jupyter notebook: image.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated_examples/demo_widgets/log_slider/","title":"Log slider widget","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated_examples/demo_widgets/log_slider/#log-slider-widget","title":"Log slider widget","text":"<p>A logarithmic scale range slider widget.</p> <p></p> <p>Out:</p> <pre><code>&lt;FunctionGui slider(input=1.0)&gt;\n</code></pre> <p></p> <pre><code>from magicgui import magicgui\n\n\n@magicgui(\n    auto_call=True,\n    result_widget=True,\n    input={\"widget_type\": \"LogSlider\", \"max\": 10000, \"min\": 1, \"tracking\": False},\n)\ndef slider(input=1):\n    \"\"\"Logarithmic scale slider.\"\"\"\n    return round(input, 4)\n\n\nslider.show(run=True)\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.071 seconds)</p> <p> Download Python source code: log_slider.py</p> <p> Download Jupyter notebook: log_slider.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated_examples/demo_widgets/login/","title":"Password login","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated_examples/demo_widgets/login/#password-login","title":"Password login","text":"<p>A password login field widget.</p> <p></p> <p>Out:</p> <pre><code>&lt;FunctionGui login(username: str = '', password: str = '', password2: str = '')&gt;\n</code></pre> <p></p> <pre><code>from magicgui import magicgui\n\n\n# note that \"password\" is a special keyword argument\n# it will create a password field in the gui by default\n# (unless you override \"widget_type\")\n# whereas \"password2\" will be a normal text field\n# (unless you override \"widget_type\")\n@magicgui(password2={\"widget_type\": \"Password\"})\ndef login(username: str, password: str, password2: str):\n    \"\"\"User login credentials.\"\"\"\n    ...\n\n\nlogin.show(run=True)\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.094 seconds)</p> <p> Download Python source code: login.py</p> <p> Download Jupyter notebook: login.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated_examples/demo_widgets/mg_execution_times/","title":"Computation times","text":"<p>00:01.224 total execution time for generated_examples_demo_widgets files:</p> <p>+--------------------------------------------------------------------------------+-----------+--------+ | table (docs/examples/demo_widgets/table.py)                      | 00:00.337 | 0.0 MB | +--------------------------------------------------------------------------------+-----------+--------+ | range_slider (docs/examples/demo_widgets/range_slider.py) | 00:00.239 | 0.0 MB | +--------------------------------------------------------------------------------+-----------+--------+ | file_dialog (docs/examples/demo_widgets/file_dialog.py)    | 00:00.128 | 0.0 MB | +--------------------------------------------------------------------------------+-----------+--------+ | login (docs/examples/demo_widgets/login.py)                      | 00:00.094 | 0.0 MB | +--------------------------------------------------------------------------------+-----------+--------+ | choices (docs/examples/demo_widgets/choices.py)                | 00:00.091 | 0.0 MB | +--------------------------------------------------------------------------------+-----------+--------+ | selection (docs/examples/demo_widgets/selection.py)          | 00:00.083 | 0.0 MB | +--------------------------------------------------------------------------------+-----------+--------+ | log_slider (docs/examples/demo_widgets/log_slider.py)       | 00:00.071 | 0.0 MB | +--------------------------------------------------------------------------------+-----------+--------+ | optional (docs/examples/demo_widgets/optional.py)             | 00:00.071 | 0.0 MB | +--------------------------------------------------------------------------------+-----------+--------+ | change_label (docs/examples/demo_widgets/change_label.py) | 00:00.064 | 0.0 MB | +--------------------------------------------------------------------------------+-----------+--------+ | image (docs/examples/demo_widgets/image.py)                      | 00:00.046 | 0.0 MB | +--------------------------------------------------------------------------------+-----------+--------+</p>"},{"location":"generated_examples/demo_widgets/optional/","title":"Optional user choice","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated_examples/demo_widgets/optional/#optional-user-choice","title":"Optional user choice","text":"<p>Optional user input using a dropdown selection widget.</p> <p></p> <p>Out:</p> <pre><code>&lt;FunctionGui f(path: str = None)&gt;\n</code></pre> <p></p> <pre><code>from typing import Optional\n\nfrom magicgui import magicgui\n\n\n# Using optional will add a '----' to the combobox, which returns \"None\"\n@magicgui(path={\"choices\": [\"a\", \"b\"]})\ndef f(path: Optional[str] = None):\n    \"\"\"\u00d6ptional user input function.\"\"\"\n    print(path, type(path))\n\n\nf.show(run=True)\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.071 seconds)</p> <p> Download Python source code: optional.py</p> <p> Download Jupyter notebook: optional.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated_examples/demo_widgets/range_slider/","title":"Range slider widget","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated_examples/demo_widgets/range_slider/#range-slider-widget","title":"Range slider widget","text":"<p>A double ended range slider widget.</p> <p></p> <p>Out:</p> <pre><code>&lt;FunctionGui func(range_value: Tuple[int, int] = (20, 380))&gt;\n</code></pre> <p></p> <pre><code>from typing import Tuple\n\nfrom magicgui import magicgui\n\n\n@magicgui(auto_call=True, range_value={\"widget_type\": \"RangeSlider\", \"max\": 500})\ndef func(range_value: Tuple[int, int] = (20, 380)):\n    \"\"\"Double ended range slider.\"\"\"\n    print(range_value)\n\n\nfunc.show(run=True)\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.239 seconds)</p> <p> Download Python source code: range_slider.py</p> <p> Download Jupyter notebook: range_slider.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated_examples/demo_widgets/selection/","title":"Multiple selection widget","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated_examples/demo_widgets/selection/#multiple-selection-widget","title":"Multiple selection widget","text":"<p>A selection widget allowing multiple selections by the user.</p> <p></p> <p>Out:</p> <pre><code>&lt;FunctionGui my_widget(pick_some=['first'])&gt;\n</code></pre> <p></p> <pre><code>from magicgui import magicgui\n\n\n@magicgui(\n    pick_some={\n        \"choices\": (\"first\", \"second\", \"third\", \"fourth\"),\n        \"allow_multiple\": True,\n    }\n)\ndef my_widget(pick_some=(\"first\")):\n    \"\"\"Dropdown selection function.\"\"\"\n    print(\"you selected\", pick_some)\n\n\nmy_widget.show(run=True)\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.083 seconds)</p> <p> Download Python source code: selection.py</p> <p> Download Jupyter notebook: selection.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated_examples/demo_widgets/table/","title":"Table widget","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated_examples/demo_widgets/table/#table-widget","title":"Table widget","text":"<p>Demonstrating a few ways to input tables.</p> <p></p> <p>Out:</p> <pre><code>Table(shape=(6, 3) at 0x145782a50)\n</code></pre> <p></p> <pre><code>import numpy as np\n\nfrom magicgui.widgets import Table\n\n# all of these are valid data types\ndict_of_lists = {\"col_1\": [1, 4], \"col_2\": [2, 5], \"col_3\": [3, 6]}\n# column-dict-of-row-dicts\ndict_of_dict = {\n    \"col_1\": {\"r1\": 1, \"r2\": 4},\n    \"col_2\": {\"r1\": 2, \"r2\": 5},\n    \"col_3\": {\"r1\": 3, \"r2\": 6},\n}\n# list-of-lists\nlist_of_list = [[1, 2, 3], [4, 5, 6]]\n# Records: List-of-column-dict\nlist_of_records = [\n    {\"col_1\": 1, \"col_2\": 2, \"col_3\": 3},\n    {\"col_1\": 4, \"col_2\": 5, \"col_3\": 6},\n]\n\n# 3-tuple of data, index, column\ndata_index_column_tuple = (([[1, 2, 3], [4, 5, 6]], (\"r1\", \"r2\"), (\"c1\", \"c2\", \"c3\")),)\n# split-dict\nsplit_dict = {\n    \"data\": [[1, 2, 3], [4, 5, 6]],\n    \"index\": (\"r1\", \"r2\"),\n    \"columns\": (\"c1\", \"c2\", \"c3\"),\n}\n\ntable = Table(value=dict_of_lists)\n\n# it behaves like a dict:\ntable[\"new_col\"] = [5, 5]\nassert table.pop(\"new_col\") == [5, 5]\n# keys and items have both regular (column) and \"row\" modes\ncol_item_view = table.items()  # iterate col_header/column\nrow_item_view = table.items(\"row\")  # iterate row_header/row\n\n# we can just call dict() to get back our dict of lists\nassert dict(table) == dict_of_lists\n# or use one of many other exports in `to_dict`\nassert table.to_dict(\"records\") == list_of_records\n\n# change headers\ntable.row_headers = (\"row1\", \"row2\")\ntable.column_headers = (\"a\", \"b\", \"c\")\n\n# setting value clears and resets the table:\ntable.value = np.arange(18).reshape(6, 3)\n# we can get/set/delete the 2D data table using numpy-style indexing:\n# get every other row\nassert table.data[::2] == [[0, 1, 2], [6, 7, 8], [12, 13, 14]]\n# set every other column in the 3rd row\ntable.data[2, ::2] = [99, 99]\n\n# export to numpy or pandas\n# table.data.to_numpy()\n# table.to_dataframe()\n\n# the table.changed event emits a dict of information on any cell change\n# e.g. {'data': 'sdfg', 'row': 1, 'column': 0, 'column_header': '1', 'row_header': '1'}\ntable.changed.connect(print)\ntable.show(run=True)\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.337 seconds)</p> <p> Download Python source code: table.py</p> <p> Download Jupyter notebook: table.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated_examples/matplotlib/mg_execution_times/","title":"Computation times","text":"<p>00:00.727 total execution time for generated_examples_matplotlib files:</p> <p>+------------------------------------------------------------------------+-----------+--------+ | waveform (docs/examples/matplotlib/waveform.py)       | 00:00.380 | 0.0 MB | +------------------------------------------------------------------------+-----------+--------+ | mpl_figure (docs/examples/matplotlib/mpl_figure.py) | 00:00.346 | 0.0 MB | +------------------------------------------------------------------------+-----------+--------+</p>"},{"location":"generated_examples/matplotlib/mpl_figure/","title":"matplotlib figure example","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated_examples/matplotlib/mpl_figure/#matplotlib-figure-example","title":"matplotlib figure example","text":"<p>Basic example of adding a generic QWidget to a container.</p> <p>Main lesson: add your QWidget to container.native.layout() as shown on line 30</p> <p></p> <p>Out:</p> <pre><code>&lt;FunctionGui f(position: int = 0)&gt;\n</code></pre> <p></p> <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nfrom matplotlib.backends.backend_qt5agg import FigureCanvas\n\nfrom magicgui import magicgui\n\nx = np.linspace(0, 5, 256)\ny = np.linspace(0, 5, 256)[:, np.newaxis]\ndata = np.sin(x) ** 10 + np.cos(10 + y * x) * np.cos(x)\n\nmpl_fig = plt.figure()\nax = mpl_fig.add_subplot(111)\n(line,) = ax.plot(data[123])  # linescan through the middle of the image\n\n\n@magicgui(position={\"widget_type\": \"Slider\", \"max\": 255}, auto_call=True)\ndef f(position: int):\n    \"\"\"Function demonstrating magicgui combined with matplotlib.\"\"\"\n    line.set_ydata(data[position])\n    line.figure.canvas.draw()\n\n\n# rather than using the Container.append (`f.append`) ...\n# grab the native layout and add the QWidget to it\nf.native.layout().addWidget(FigureCanvas(mpl_fig))\n\nf.show(run=True)\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.346 seconds)</p> <p> Download Python source code: mpl_figure.py</p> <p> Download Jupyter notebook: mpl_figure.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated_examples/matplotlib/waveform/","title":"Waveforms example","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated_examples/matplotlib/waveform/#waveforms-example","title":"Waveforms example","text":"<p>Simple waveform generator widget, with plotting.</p> <p></p> <p>Out:</p> <pre><code>&lt;Container (signal_widget: NoneType, sine: NoneType)&gt;\n</code></pre> <p></p> <pre><code>from dataclasses import dataclass, field\nfrom enum import Enum\nfrom functools import partial\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom matplotlib.backends.backend_qt5agg import FigureCanvas\nfrom scipy import signal\nfrom typing_extensions import Annotated\n\nfrom magicgui import magicgui, register_type, widgets\n\nregister_type(float, widget_type=\"FloatSlider\")\nregister_type(int, widget_type=\"Slider\")\n\nFreq = Annotated[float, {\"min\": 0.001, \"max\": 30.0}]\nPhase = Annotated[float, {\"min\": 0.0, \"max\": 360.0}]\nDuty = Annotated[float, {\"min\": 0.0, \"max\": 1.0}]\nTime = Annotated[float, {\"min\": 0.01, \"max\": 100.0}]\n\n\n@dataclass\nclass Signal:\n    \"\"\"Constructs a 1D signal.\n\n    As is, this class is not very useful, but one could add callbacks\n    or more functionality here\n\n    Parameters\n    ----------\n    func : callable\n        func must take a 'time' array as sole argument and return a 1D array with the\n        same size as the input\n    duration : float\n        the maximum of the input time array\n    size : int\n        the number of samples in the time array\n\n    \"\"\"\n\n    func: callable\n    duration: Time = 1.0\n    size: int = 500\n    time: np.ndarray = field(init=False)\n    data: np.ndarray = field(init=False)\n\n    def __post_init__(self):\n        \"\"\"Evaluate the function at instantiation time.\"\"\"\n        self.time = np.linspace(0, self.duration, self.size)\n        self.data = self.func(self.time)\n\n    def plot(self, ax=None, **kwargs):\n        \"\"\"Plots the data.\n\n        Parameters\n        ----------\n        ax: matplotlib.axes.Axes instance, default None\n           if provided the plot is done on this axes instance.\n           If None a new ax is created\n        **kwargs: Keyword arguments that are passed on to\n            the matplotib ax.plot method\n\n        Returns\n        -------\n        fig: a matplotlib.figure.Figure instance\n        ax: matplotlib.axes.Axes instance\n        \"\"\"\n        if ax is None:\n            fig, ax = plt.subplots()\n        else:\n            fig = ax.get_figure()\n        ax.plot(self.time, self.data, **kwargs)\n        return fig, ax\n\n\ndef sine(\n    duration: Time = 10.0, size: int = 500, freq: Freq = 0.5, phase: Phase = 0.0\n) -&gt; Signal:\n    \"\"\"Returns a 1D sine wave.\n\n    Parameters\n    ----------\n    duration: float\n       the duration of the signal in seconds\n    size: int\n        the number of samples in the signal time array\n    freq: float\n       the frequency of the signal in Hz\n    phase: Phase\n       the phase of the signal (in degrees)\n    \"\"\"\n    sig = Signal(\n        duration=duration,\n        size=size,\n        func=lambda t: np.sin(t * (2 * np.pi * freq) + phase * np.pi / 180),\n    )\n    return sig\n\n\ndef chirp(\n    duration: Time = 10.0,\n    size: int = 500,\n    f0: float = 1.0,\n    t1: Time = 5.0,\n    f1: float = 2.0,\n    phase: Phase = 0.0,\n) -&gt; Signal:\n    \"\"\"Frequency-swept cosine generator.\n\n    See scipy.signal.chirp\n    \"\"\"\n    sig = Signal(\n        duration=duration,\n        size=size,\n        func=partial(signal.chirp, f0=f0, t1=t1, f1=f1, phi=phase),\n    )\n    return sig\n\n\ndef sawtooth(\n    duration: Time = 10.0,\n    size: int = 500,\n    freq: Freq = 1.0,\n    width: Duty = 1.0,\n    phase: Phase = 0.0,\n) -&gt; Signal:\n    \"\"\"Return a periodic sawtooth or triangle waveform.\n\n    See scipy.signal.sawtooth\n    \"\"\"\n    sig = Signal(\n        duration=duration,\n        size=size,\n        func=lambda t: signal.sawtooth(\n            2 * np.pi * freq * t + phase * np.pi / 180, width=width\n        ),\n    )\n    return sig\n\n\ndef square(\n    duration: Time = 10.0, size: int = 500, freq: Freq = 1.0, duty: Duty = 0.5\n) -&gt; Signal:\n    \"\"\"Return a periodic sawtooth or triangle waveform.\n\n    See scipy.signal.square\n    \"\"\"\n    sig = Signal(\n        duration=duration,\n        size=size,\n        func=lambda t: signal.square(2 * np.pi * freq * t, duty=duty),\n    )\n    return sig\n\n\ndef on_off(\n    duration: Time = 10.0, size: int = 500, t_on: Time = 0.01, t_off: Time = 0.01\n) -&gt; Signal:\n    \"\"\"On/Off signal function.\"\"\"\n    data = np.ones(size)\n    data[: int(size * t_on / duration)] = -1\n    if t_off &gt; 0:\n        data[int(size * t_off / duration) :] = -1\n    sig = Signal(duration=duration, size=size, func=lambda t: data)\n    return sig\n\n\nWAVEFORMS = {\n    \"sine\": sine,\n    \"chirp\": chirp,\n    \"sawtooth\": sawtooth,\n    \"square\": square,\n    \"on_off\": on_off,\n}\n\n\nclass Select(Enum):\n    \"\"\"Enumeration to select signal type.\"\"\"\n\n    OnOff = \"on_off\"\n    Sine = \"sine\"\n    Chirp = \"chirp\"\n    Sawtooth = \"sawtooth\"\n    Square = \"square\"\n\n\nclass WaveForm(widgets.Container):\n    \"\"\"Simple waveform generator widget, with plotting.\"\"\"\n\n    def __init__(self):\n        \"\"\"Creates the widget.\"\"\"\n        super().__init__()\n        self.fig, self.ax = plt.subplots()\n        self.native.layout().addWidget(FigureCanvas(self.fig))\n        self.waveform = sine\n        self.controls = None\n        self.append(self.signal_widget)\n        self.update_controls()\n        self.update_graph(sine())\n\n    @magicgui(auto_call=True)\n    def signal_widget(self, select: Select = Select.Sine) -&gt; widgets.Container:\n        \"\"\"Waveform selection, from the WAVEFORMS dict.\"\"\"\n        self.waveform = WAVEFORMS[select.value]\n        self.update_controls()\n        self.update_graph(self.waveform())\n\n    def update_controls(self):\n        \"\"\"Reset controls according to the new function.\"\"\"\n        if self.controls is not None:\n            self.remove(self.controls)\n        self.controls = magicgui(auto_call=True)(self.waveform)\n        self.append(self.controls)\n        self.controls.called.connect(self.update_graph)\n\n    def update_graph(self, sig: Signal):\n        \"\"\"Re-plot when a parameter changes.\n\n        Note\n        ----\n        For big data, this could be slow, maybe `auto_call` should\n        not be true in the method above...\n        \"\"\"\n        self.ax.cla()\n        sig.plot(ax=self.ax)\n        self.fig.canvas.draw()\n\n\nwaveform = WaveForm()\nwaveform.show(run=True)\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.380 seconds)</p> <p> Download Python source code: waveform.py</p> <p> Download Jupyter notebook: waveform.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated_examples/napari/mg_execution_times/","title":"Computation times","text":"<p>00:20.757 total execution time for generated_examples_napari files:</p> <p>+--------------------------------------------------------------------------------------------------------+-----------+--------+ | napari_combine_qt (docs/examples/napari/napari_combine_qt.py)                | 00:12.845 | 0.0 MB | +--------------------------------------------------------------------------------------------------------+-----------+--------+ | napari_parameter_sweep (docs/examples/napari/napari_parameter_sweep.py) | 00:04.707 | 0.0 MB | +--------------------------------------------------------------------------------------------------------+-----------+--------+ | napari_img_math (docs/examples/napari/napari_img_math.py)                      | 00:03.102 | 0.0 MB | +--------------------------------------------------------------------------------------------------------+-----------+--------+ | napari_forward_refs (docs/examples/napari/napari_forward_refs.py)          | 00:00.103 | 0.0 MB | +--------------------------------------------------------------------------------------------------------+-----------+--------+</p>"},{"location":"generated_examples/napari/napari_combine_qt/","title":"napari Qt demo","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated_examples/napari/napari_combine_qt/#napari-qt-demo","title":"napari Qt demo","text":"<p>Napari provides a few conveniences with magicgui, and one of the most commonly used is the layer combo box that gets created when a parameter is annotated as napari.layers.Layer.</p> <p>The layer box will stay in sync with the viewer model, adding and removing layers as needed.</p> <p>This example shows how to use just that widget in the context of a larger custom QWidget.</p> <p></p> <pre><code>import napari\nfrom qtpy.QtWidgets import QVBoxLayout, QWidget\n\nfrom magicgui.widgets import create_widget\n\n\nclass CustomWidget(QWidget):\n    \"\"\"A custom widget class.\"\"\"\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.setLayout(QVBoxLayout())\n        # change annotation to napari.layers.Image (e.g) to restrict to just Images\n        self._layer_combo = create_widget(annotation=napari.layers.Layer)\n        # magicgui widgets hold the Qt widget at `widget.native`\n        self.layout().addWidget(self._layer_combo.native)\n\n\nviewer = napari.Viewer()\nviewer.add_points()\nviewer.add_points()\n\nmy_widget = CustomWidget()\nviewer.window.add_dock_widget(my_widget)\n\n# when my_widget is a magicgui.Widget, it will detect that it has been added\n# to a viewer, and automatically update the choices.  Otherwise, you need to\n# trigger this yourself:\nmy_widget._layer_combo.reset_choices()\nviewer.layers.events.inserted.connect(my_widget._layer_combo.reset_choices)\nviewer.layers.events.removed.connect(my_widget._layer_combo.reset_choices)\n\nnapari.run()\n</code></pre> <p>Total running time of the script: ( 0 minutes  12.845 seconds)</p> <p> Download Python source code: napari_combine_qt.py</p> <p> Download Jupyter notebook: napari_combine_qt.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated_examples/napari/napari_forward_refs/","title":"napari forward reference demo","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated_examples/napari/napari_forward_refs/#napari-forward-reference-demo","title":"napari forward reference demo","text":"<p>Example of using a ForwardRef to avoid importing a module that provides a widget.</p> <p>In this example, one might want to create a widget that takes as an argument a napari Image layer, and returns an Image.  In order to avoid needing to import napari (and therefore depending directly on napari), it's possible to annotate those parameters with a string representation of the type (rather than the type itself).  This is called a \"forward reference\": https://www.python.org/dev/peps/pep-0484/#forward-references</p> <p></p> <p>Out:</p> <pre><code>&lt;FunctionGui subtract_background(data: napari.types.ImageData = None, background: int = 50) -&gt; napari.types.ImageData&gt;\n</code></pre> <p></p> <pre><code># Note: if you'd like to avoid circular imports, or just want to avoid having your\n# linter yell at you for an undefined type annotation, you can place the import\n# inside of an `if typing.TYPE_CHECKING` conditional.  This is not evaluated at runtime,\n# only when something like mypy is doing type checking.\nfrom typing import TYPE_CHECKING\n\nfrom magicgui import magicgui\n\nif TYPE_CHECKING:\n    import napari\n\n\n@magicgui(call_button=\"execute\", background={\"max\": 200})\ndef subtract_background(\n    data: \"napari.types.ImageData\", background: int = 50\n) -&gt; \"napari.types.ImageData\":\n    \"\"\"Subtract a constant from the data.\"\"\"\n    if data:\n        return data - background\n\n\nsubtract_background.show(run=True)\n# now, this example isn't all that interesting on its own (since there will be no Image\n# layer in the dropdown) ... but in another package, where you DO import napari,\n# you could add this widget to a napari viewer with\n# viewer.window.add_dock_widget(subtract_background)\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.103 seconds)</p> <p> Download Python source code: napari_forward_refs.py</p> <p> Download Jupyter notebook: napari_forward_refs.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated_examples/napari/napari_img_math/","title":"napari image arithmetic widget","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated_examples/napari/napari_img_math/#napari-image-arithmetic-widget","title":"napari image arithmetic widget","text":"<p>napari is a fast, interactive, multi-dimensional image viewer for python.  It uses Qt for the GUI, so it's easy to extend napari with small, composable widgets created with <code>magicgui</code>.  Here we're going to build this simple image arithmetic widget with a few additional lines of code.</p> <p>For napari-specific magicgui documentation, see the napari docs</p> <p></p>"},{"location":"generated_examples/napari/napari_img_math/#outline","title":"outline","text":"<p>This example demonstrates how to:</p> <ol> <li> <p>Create a <code>magicgui</code> widget that can be used in another program (napari)</p> </li> <li> <p>Use an <code>Enum</code> to create a dropdown menu</p> </li> <li> <p>Connect some event listeners to create interactivity.</p> </li> </ol>"},{"location":"generated_examples/napari/napari_img_math/#code","title":"code","text":"<p>Code follows, with explanation below... You can also get this example at github.</p> <pre><code>from enum import Enum\n\nimport napari\nimport numpy\nfrom napari.types import ImageData\n\nfrom magicgui import magicgui\n\n\nclass Operation(Enum):\n    # A set of valid arithmetic operations for image_arithmetic.\n    #\n    # To create nice dropdown menus with magicgui, it's best\n    # (but not required) to use Enums.  Here we make an Enum\n    # class for all of the image math operations we want to\n    # allow.\n    add = numpy.add\n    subtract = numpy.subtract\n    multiply = numpy.multiply\n    divide = numpy.divide\n\n\n# here's the magicgui!  We also use the additional\n# `call_button` option\n@magicgui(call_button=\"execute\")\ndef image_arithmetic(\n    layerA: ImageData, operation: Operation, layerB: ImageData\n) -&gt; ImageData:\n    # Add, subtracts, multiplies, or divides to image layers.\n    return operation.value(layerA, layerB)\n\n# create a viewer and add a couple image layers\nviewer = napari.Viewer()\nviewer.add_image(numpy.random.rand(20, 20), name=\"Layer 1\")\nviewer.add_image(numpy.random.rand(20, 20), name=\"Layer 2\")\n\n# add our new magicgui widget to the viewer\nviewer.window.add_dock_widget(image_arithmetic)\n\n# keep the dropdown menus in the gui in sync with the layer model\nviewer.layers.events.inserted.connect(image_arithmetic.reset_choices)\nviewer.layers.events.removed.connect(image_arithmetic.reset_choices)\n\nnapari.run()\n</code></pre>"},{"location":"generated_examples/napari/napari_img_math/#walkthrough","title":"walkthrough","text":"<p>We're going to go a little out of order so that the other code makes more sense. Let's start with the actual function we'd like to write to do some image arithmetic.</p>"},{"location":"generated_examples/napari/napari_img_math/#the-function","title":"the function","text":"<p>Our function takes two <code>numpy</code> arrays (in this case, from Image layers), and some mathematical operation (we'll restrict the options using an <code>enum.Enum</code>). When called, ourfunction calls the selected operation on the data.</p> <pre><code>def image_arithmetic(array1, operation, array2):\n    return operation.value(array1, array2)\n</code></pre>"},{"location":"generated_examples/napari/napari_img_math/#type-annotations","title":"type annotations","text":"<p><code>magicgui</code> works particularly well with type annotations, and allows third-party libraries to register widgets and behavior for handling their custom types (using <code>magicgui.type_map.register_type</code>). <code>napari</code> provides support for <code>magicgui</code> by registering a dropdown menu whenever a function parameter is annotated as one of the basic napari <code>Layer</code> types, or, in this case, <code>ImageData</code> indicates we just the <code>data</code> attribute of the layer. Furthermore, it recognizes when a function has a <code>napari.layers.Layer</code> or <code>LayerData</code> return type annotation, and will add the result to the viewer. So we gain a lot by annotating the above function with the appropriate <code>napari</code> types.</p> <pre><code>from napari.types import ImageData\n\ndef image_arithmetic(\n    layerA: ImageData, operation: Operation, layerB: ImageData\n) -&gt; ImageData:\n    return operation.value(layerA, layerB)\n</code></pre>"},{"location":"generated_examples/napari/napari_img_math/#the-magic-part","title":"the magic part","text":"<p>Finally, we decorate the function with <code>@magicgui</code> and tell it we'd like to have a <code>call_button</code> that we can click to execute the function.</p> <pre><code>@magicgui(call_button=\"execute\")\ndef image_arithmetic(layerA: ImageData, operation: Operation, layerB: ImageData):\n    return operation.value(layerA, layerB)\n</code></pre> <p>That's it!  The <code>image_arithmetic</code> function is now a FunctionGui that can be shown, or incorporated into other GUIs (such as the napari GUI shown in this example)</p> <p>!!! note While type hints     aren't always required in <code>magicgui</code>, they are recommended ... and they     are required for certain things, like the <code>Operation(Enum)</code> used here for     the dropdown and the <code>napari.types.ImageData</code>     annotations that <code>napari</code> has registered with <code>magicgui</code>.</p>"},{"location":"generated_examples/napari/napari_img_math/#create-dropdowns-with-enums","title":"create dropdowns with Enums","text":"<p>We'd like the user to be able to select the operation (<code>add</code>, <code>subtract</code>, <code>multiply</code>, <code>divide</code>) using a dropdown menu. <code>enum.Enum</code> offers a convenient way to restrict values to a strict set of options, while providing <code>name: value</code> pairs for each of the options. Here, the value for each choice is the actual function we would like to have called when that option is selected.</p> <pre><code>class Operation(enum.Enum):\n    add = numpy.add\n    subtract = numpy.subtract\n    multiply = numpy.multiply\n    divide = numpy.divide\n</code></pre>"},{"location":"generated_examples/napari/napari_img_math/#add-it-to-napari","title":"add it to napari","text":"<p>When we decorated the <code>image_arithmetic</code> function above, it became a FunctionGui.  Napari recognizes this type, so we can simply add it to the napari viewer as follows:</p> <pre><code>viewer.window.add_dock_widget(image_arithmetic)\n</code></pre>"},{"location":"generated_examples/napari/napari_img_math/#connect-event-listeners-for-interactivity","title":"connect event listeners for interactivity","text":"<p>What fun is a GUI without some interactivity?  Let's make stuff happen.</p> <p>We connect the <code>image_arithmetic.reset_choices</code> function to the <code>viewer.layers.events.inserted/removed</code> event from <code>napari</code>, to make sure that the dropdown menus stay in sync if a layer gets added or removed from the napari window:</p> <pre><code>viewer.layers.events.inserted.connect(image_arithmetic.reset_choices)\nviewer.layers.events.removed.connect(image_arithmetic.reset_choices)\n</code></pre> <p>Tip</p> <p>An additional offering from <code>magicgui</code> here is that the decorated function also acquires a new attribute \"<code>called</code>\" that can be connected to callback functions of your choice.  Then, whenever the gui widget or the original function are called, the result will be passed to your callback function:</p> <pre><code>@image_arithmetic.called.connect\ndef print_mean(value):\n    # Callback function that accepts an event\n    # the value attribute has the result of calling the function\n    print(np.mean(value))\n</code></pre> <pre><code>&gt;&gt;&gt; image_arithmetic()\n1.0060037881040373\n</code></pre>"},{"location":"generated_examples/napari/napari_img_math/#code_1","title":"Code","text":"<p>Here's the full code example again.</p> <p></p> <pre><code>from enum import Enum\n\nimport napari\nimport numpy\nfrom napari.types import ImageData\n\nfrom magicgui import magicgui\n\n\nclass Operation(Enum):\n    # A set of valid arithmetic operations for image_arithmetic.\n    #\n    # To create nice dropdown menus with magicgui, it's best\n    # (but not required) to use Enums.  Here we make an Enum\n    # class for all of the image math operations we want to\n    # allow.\n    add = numpy.add\n    subtract = numpy.subtract\n    multiply = numpy.multiply\n    divide = numpy.divide\n\n\n# here's the magicgui!  We also use the additional\n# `call_button` option\n@magicgui(call_button=\"execute\")\ndef image_arithmetic(\n    layerA: ImageData, operation: Operation, layerB: ImageData\n) -&gt; ImageData:\n    # Add, subtracts, multiplies, or divides to image layers.\n    return operation.value(layerA, layerB)\n\n\n# create a viewer and add a couple image layers\nviewer = napari.Viewer()\nviewer.add_image(numpy.random.rand(20, 20), name=\"Layer 1\")\nviewer.add_image(numpy.random.rand(20, 20), name=\"Layer 2\")\n\n# add our new magicgui widget to the viewer\nviewer.window.add_dock_widget(image_arithmetic)\n\n# keep the dropdown menus in the gui in sync with the layer model\nviewer.layers.events.inserted.connect(image_arithmetic.reset_choices)\nviewer.layers.events.removed.connect(image_arithmetic.reset_choices)\n\nnapari.run()\n</code></pre> <p>Total running time of the script: ( 0 minutes  3.102 seconds)</p> <p> Download Python source code: napari_img_math.py</p> <p> Download Jupyter notebook: napari_img_math.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated_examples/napari/napari_parameter_sweep/","title":"napari parameter sweeps","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated_examples/napari/napari_parameter_sweep/#napari-parameter-sweeps","title":"napari parameter sweeps","text":"<p>napari is a fast, interactive, multi-dimensional image viewer for python.  It uses Qt for the GUI, so it's easy to extend napari with small, composable widgets created with <code>magicgui</code>.  Here, we demonstrate how to build a interactive widget that lets you immediately see the effect of changing one of the parameters of your function.</p> <p>For napari-specific magicgui documentation, see the napari docs</p> <p></p> <p>See also: Some of this tutorial overlaps with topics covered in the napari image arithmetic example.</p>"},{"location":"generated_examples/napari/napari_parameter_sweep/#outline","title":"outline","text":"<p>This example demonstrates how to:</p> <ol> <li> <p>Create a <code>magicgui</code> widget that can be used in another program (<code>napari</code>)</p> </li> <li> <p>Automatically call our function when a parameter changes</p> </li> <li> <p>Provide <code>magicgui</code> with a custom widget for a specific argument</p> </li> <li> <p>Use the <code>choices</code> option to create a dropdown</p> </li> <li> <p>Connect some event listeners to create interactivity.</p> </li> </ol>"},{"location":"generated_examples/napari/napari_parameter_sweep/#code","title":"code","text":"<p>Code follows, with explanation below... You can also get this example at github.</p> <pre><code>import napari\nimport skimage.data\nimport skimage.filters\nfrom napari.types import ImageData\n\nfrom magicgui import magicgui\n\n\n# turn the gaussian blur function into a magicgui\n# - 'auto_call' tells magicgui to call the function when a parameter changes\n# - we use 'widget_type' to override the default \"float\" widget on sigma,\n#   and provide a maximum valid value.\n# - we contstrain the possible choices for 'mode'\n@magicgui(\n    auto_call=True,\n    sigma={\"widget_type\": \"FloatSlider\", \"max\": 6},\n    mode={\"choices\": [\"reflect\", \"constant\", \"nearest\", \"mirror\", \"wrap\"]},\n    layout=\"horizontal\",\n)\ndef gaussian_blur(layer: ImageData, sigma: float = 1.0, mode=\"nearest\") -&gt; ImageData:\n    # Apply a gaussian blur to 'layer'.\n    if layer is not None:\n        return skimage.filters.gaussian(layer, sigma=sigma, mode=mode)\n\n# create a viewer and add some images\nviewer = napari.Viewer()\nviewer.add_image(skimage.data.astronaut().mean(-1), name=\"astronaut\")\nviewer.add_image(skimage.data.grass().astype(\"float\"), name=\"grass\")\n\n# Add it to the napari viewer\nviewer.window.add_dock_widget(gaussian_blur)\n# update the layer dropdown menu when the layer list changes\nviewer.layers.events.changed.connect(gaussian_blur.reset_choices)\n\nnapari.run()\n</code></pre>"},{"location":"generated_examples/napari/napari_parameter_sweep/#walkthrough","title":"walkthrough","text":"<p>We're going to go a little out of order so that the other code makes more sense. Let's start with the actual function we'd like to write to apply a gaussian filter to an image.</p>"},{"location":"generated_examples/napari/napari_parameter_sweep/#the-function","title":"the function","text":"<p>Our function is a very thin wrapper around <code>skimage.filters.gaussian</code>. It takes a <code>napari</code> Image layer, a <code>sigma</code> to control the blur radius, and a <code>mode</code> that determines how edges are handled.</p> <pre><code>def gaussian_blur(\n    layer: Image, sigma: float = 1, mode=\"nearest\"\n) -&gt; Image:\n    return filters.gaussian(layer.data, sigma=sigma, mode=mode)\n</code></pre> <p>The reasons we are wrapping it here are:</p> <ol> <li><code>filters.gaussian</code> accepts a <code>numpy</code> array,    but we want to work with <code>napari</code> layers    that store the data in a <code>layer.data</code> attribute. So we need an adapter.</li> <li>We'd like to add some type annotations to the    signature that were not provided by <code>filters.gaussian</code></li> </ol>"},{"location":"generated_examples/napari/napari_parameter_sweep/#type-annotations","title":"type annotations","text":"<p>As described in the image arithmetic example, we take advantage of napari's built in support for <code>magicgui</code> by annotating our function parameters and return value as napari <code>Layer</code> types.  <code>napari</code> will then tell <code>magicgui</code> what to do with them, creating a dropdown with a list of current layers for our <code>layer</code> parameter, and automatically adding the result of our function to the viewer when called.</p> <p>For documentation on napari types with magicgui, see the napari docs</p>"},{"location":"generated_examples/napari/napari_parameter_sweep/#the-magic-part","title":"the magic part","text":"<p>Finally, we decorate the function with <code>@magicgui</code> and provide some options.</p> <pre><code>@magicgui(\n    auto_call=True,\n    sigma={\"widget_type\": \"FloatSlider\", \"max\": 6},\n    mode={\"choices\": [\"reflect\", \"constant\", \"nearest\", \"mirror\", \"wrap\"]},\n)\ndef gaussian_blur(\n  layer: ImageData, sigma: float = 1.0, mode=\"nearest\"\n) -&gt; ImageData:\n    # Apply a gaussian blur to ``layer``.\n    if layer is not None:\n        return skimage.filters.gaussian(layer, sigma=sigma, mode=mode)\n</code></pre> <ul> <li><code>auto_call=True</code> makes it so that the <code>gaussian_blur</code> function will be called   whenever one of the parameters changes (with the current parameters set in the   GUI).</li> <li> <p>We then provide keyword arguments to modify the look &amp; behavior of <code>sigma</code>   and <code>mode</code>:</p> <ul> <li><code>\"widget_type\": \"FloatSlider\"</code> tells <code>magicgui</code> not to use the standard     (<code>float</code>) widget for the <code>sigma</code> widget, but rather to use a slider widget.</li> <li>we then set an upper limit on the slider values for <code>sigma</code>.</li> </ul> </li> <li> <p>finally, we specify valid <code>choices</code> for the <code>mode</code> argument.  This turns that   parameter into a categorical/dropdown type widget, and sets the options.</p> </li> </ul>"},{"location":"generated_examples/napari/napari_parameter_sweep/#connecting-events","title":"connecting events","text":"<p>As described in the Events documentation, we can also connect any callback to the <code>gaussian_blur.called</code> signal that will receive the result of our decorated function anytime it is called.</p> <pre><code>def do_something_with_result(result):\n    ...\n\ngaussian_blur.called.connect(do_something_with_result)\n</code></pre>"},{"location":"generated_examples/napari/napari_parameter_sweep/#code_1","title":"Code","text":"<p>Here's the full code example again.</p> <p></p> <pre><code>import napari\nimport skimage.data\nimport skimage.filters\nfrom napari.types import ImageData\n\nfrom magicgui import magicgui\n\n\n# turn the gaussian blur function into a magicgui\n# - 'auto_call' tells magicgui to call the function when a parameter changes\n# - we use 'widget_type' to override the default \"float\" widget on sigma,\n#   and provide a maximum valid value.\n# - we contstrain the possible choices for 'mode'\n@magicgui(\n    auto_call=True,\n    sigma={\"widget_type\": \"FloatSlider\", \"max\": 6},\n    mode={\"choices\": [\"reflect\", \"constant\", \"nearest\", \"mirror\", \"wrap\"]},\n    layout=\"horizontal\",\n)\ndef gaussian_blur(layer: ImageData, sigma: float = 1.0, mode=\"nearest\") -&gt; ImageData:\n    # Apply a gaussian blur to 'layer'.\n    if layer is not None:\n        return skimage.filters.gaussian(layer, sigma=sigma, mode=mode)\n\n\n# create a viewer and add some images\nviewer = napari.Viewer()\nviewer.add_image(skimage.data.astronaut().mean(-1), name=\"astronaut\")\nviewer.add_image(skimage.data.grass().astype(\"float\"), name=\"grass\")\n\n# Add it to the napari viewer\nviewer.window.add_dock_widget(gaussian_blur)\n# update the layer dropdown menu when the layer list changes\nviewer.layers.events.changed.connect(gaussian_blur.reset_choices)\n\nnapari.run()\n</code></pre> <p>Total running time of the script: ( 0 minutes  4.707 seconds)</p> <p> Download Python source code: napari_parameter_sweep.py</p> <p> Download Jupyter notebook: napari_parameter_sweep.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated_examples/notebooks/magicgui_jupyter/","title":"Jupyter notebooks and magicgui","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated_examples/notebooks/magicgui_jupyter/#jupyter-notebooks-and-magicgui","title":"Jupyter notebooks and magicgui","text":"<p>This example shows magicgui widgets embedded in a jupyter notebook.</p> <p>The key function here is <code>use_app(\"ipynb\")</code>.</p> <p>You can also get this example at github.</p> <pre><code>import math\nfrom enum import Enum\n\nfrom magicgui import magicgui, use_app\nuse_app(\"ipynb\")\n\nclass Medium(Enum):\n    # Various media and their refractive indices.\n    Glass = 1.520\n    Oil = 1.515\n    Water = 1.333\n    Air = 1.0003\n\n\n@magicgui(\n    call_button=\"calculate\", result_widget=True, layout='vertical', auto_call=True\n)\ndef snells_law(aoi=1.0, n1=Medium.Glass, n2=Medium.Water, degrees=True):\n    # Calculate the angle of refraction given two media and an angle of incidence.\n    if degrees:\n        aoi = math.radians(aoi)\n    try:\n        n1 = n1.value\n        n2 = n2.value\n        result = math.asin(n1 * math.sin(aoi) / n2)\n        return round(math.degrees(result) if degrees else result, 2)\n    except ValueError:  # math domain error\n        return \"TIR!\"\n\n\nsnells_law\n</code></pre> <p></p> <p>Total running time of the script: ( 0 minutes  0.000 seconds)</p> <p> Download Python source code: magicgui_jupyter.py</p> <p> Download Jupyter notebook: magicgui_jupyter.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated_examples/notebooks/mg_execution_times/","title":"Computation times","text":"<p>00:00.000 total execution time for generated_examples_notebooks files:</p> <p>+-----------------------------------------------------------------------------------------+-----------+--------+ | magicgui_jupyter (docs/examples/notebooks/magicgui_jupyter.py) | 00:00.000 | 0.0 MB | +-----------------------------------------------------------------------------------------+-----------+--------+</p>"},{"location":"generated_examples/progress_bars/mg_execution_times/","title":"Computation times","text":"<p>00:00.225 total execution time for generated_examples_progress_bars files:</p> <p>+---------------------------------------------------------------------------------------------------------------+-----------+--------+ | progress_nested (docs/examples/progress_bars/progress_nested.py)                      | 00:00.070 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------+-----------+--------+ | progress (docs/examples/progress_bars/progress.py)                                           | 00:00.065 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------+-----------+--------+ | progress_manual (docs/examples/progress_bars/progress_manual.py)                      | 00:00.057 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------+-----------+--------+ | progress_indeterminate (docs/examples/progress_bars/progress_indeterminate.py) | 00:00.034 | 0.0 MB | +---------------------------------------------------------------------------------------------------------------+-----------+--------+</p>"},{"location":"generated_examples/progress_bars/progress/","title":"Simple progress bar","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated_examples/progress_bars/progress/#simple-progress-bar","title":"Simple progress bar","text":"<p>A simple progress bar demo with magicgui.</p> <p></p> <p>Out:</p> <pre><code>&lt;FunctionGui long_running(steps=10, delay=0.1)&gt;\n</code></pre> <p></p> <pre><code>from time import sleep\n\nfrom magicgui import magicgui\nfrom magicgui.tqdm import trange\n\n# if magicui.tqdm.tqdm or trange are used outside of a @magicgui function, (such as in\n# interactive use in IPython), then they fall back to the standard terminal output\n\n\n# If use inside of a magicgui-decorated function\n# a progress bar widget will be added to the magicgui container\n@magicgui(call_button=True, layout=\"horizontal\")\ndef long_running(steps=10, delay=0.1):\n    \"\"\"Long running computation with range iterator.\"\"\"\n    # trange(steps) is a shortcut for `tqdm(range(steps))`\n    for _i in trange(steps):\n        sleep(delay)\n\n\nlong_running.show(run=True)\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.065 seconds)</p> <p> Download Python source code: progress.py</p> <p> Download Jupyter notebook: progress.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated_examples/progress_bars/progress_indeterminate/","title":"Indeterminate progress bar","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated_examples/progress_bars/progress_indeterminate/#indeterminate-progress-bar","title":"Indeterminate progress bar","text":"<p>Example of an indeterminate progress bar for a long running computation of unknown time.</p> <p></p> <p>Out:</p> <pre><code>&lt;FunctionGui long_running(sleep_time=5)&gt;\n</code></pre> <p></p> <pre><code>import time\n\nfrom superqt.utils import thread_worker\n\nfrom magicgui import magicgui\nfrom magicgui.tqdm import tqdm\n\n\n@magicgui(call_button=True, layout=\"horizontal\")\ndef long_running(sleep_time=5):\n    \"\"\"Long running computation with an indeterminate progress bar.\"\"\"\n    # Here tqdm is not provided an iterable argument, or the 'total' kwarg\n    # so it cannot calculate the expected number of iterations\n    # which means it will create an indeterminate progress bar\n    with tqdm() as pbar:\n        # It is best practice to use a separate thread for long running computations\n        # This makes the function non-blocking, you can still interact with the widget\n        @thread_worker(connect={\"finished\": lambda: pbar.progressbar.hide()})\n        def sleep(secs):\n            time.sleep(secs)\n\n        sleep(sleep_time)\n\n\nlong_running.show(run=True)\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.034 seconds)</p> <p> Download Python source code: progress_indeterminate.py</p> <p> Download Jupyter notebook: progress_indeterminate.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated_examples/progress_bars/progress_manual/","title":"Manual progress bar","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated_examples/progress_bars/progress_manual/#manual-progress-bar","title":"Manual progress bar","text":"<p>Example of a progress bar being updated manually.</p> <p></p> <p>Out:</p> <pre><code>&lt;FunctionGui manual(pbar: magicgui.widgets.ProgressBar = ProgressBar(value=&lt;function match_type.&lt;locals&gt;.&lt;lambda&gt; at 0x14ca93f60&gt;, annotation=&lt;class 'magicgui.widgets.ProgressBar'&gt;, name='pbar'), increment: bool = 1)&gt;\n</code></pre> <p></p> <pre><code>from magicgui import magicgui\nfrom magicgui.widgets import ProgressBar\n\n\n@magicgui(call_button=\"tick\", pbar={\"min\": 0, \"step\": 2, \"max\": 20, \"value\": 0})\ndef manual(pbar: ProgressBar, increment: bool = True):\n    \"\"\"Example of manual progress bar control.\"\"\"\n    if increment:\n        pbar.increment()\n    else:\n        pbar.decrement()\n\n\nmanual.show(run=True)\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.057 seconds)</p> <p> Download Python source code: progress_manual.py</p> <p> Download Jupyter notebook: progress_manual.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated_examples/progress_bars/progress_nested/","title":"Nested progress bars","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated_examples/progress_bars/progress_nested/#nested-progress-bars","title":"Nested progress bars","text":"<p>Example using nested progress bars in magicgui.</p> <p></p> <p>Out:</p> <pre><code>&lt;FunctionGui long_function(steps=10, repeats=4, choices='ABCDEFGHIJKLMNOP12345679', char='', delay=0.05)&gt;\n</code></pre> <p></p> <pre><code>import random\nfrom time import sleep\n\nfrom magicgui import magicgui\nfrom magicgui.tqdm import tqdm, trange\n\n# if magicui.tqdm.tqdm or trange are used outside of a @magicgui function, (such as in\n# interactive use in IPython), then they fall back to the standard terminal output\n\n\n# If use inside of a magicgui-decorated function\n# a progress bar widget will be added to the magicgui container\n@magicgui(call_button=True, layout=\"vertical\")\ndef long_function(\n    steps=10, repeats=4, choices=\"ABCDEFGHIJKLMNOP12345679\", char=\"\", delay=0.05\n):\n    \"\"\"Long running computation with nested iterators.\"\"\"\n    # trange and tqdm accept all the kwargs from tqdm itself, as well as any\n    # valid kwargs for magicgui.widgets.ProgressBar, (such as \"label\")\n    for _r in trange(repeats, label=\"repeats\"):\n        letters = [random.choice(choices) for _ in range(steps)]\n        # `tqdm`, like `tqdm`, accepts any iterable\n        # this progress bar is nested and will be run &amp; reset multiple times\n        for letter in tqdm(letters, label=\"steps\"):\n            long_function.char.value = letter\n            sleep(delay)\n\n\nlong_function.show(run=True)\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.070 seconds)</p> <p> Download Python source code: progress_nested.py</p> <p> Download Jupyter notebook: progress_nested.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated_examples/under_the_hood/class_method/","title":"Deocrate class methods with magicgui","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated_examples/under_the_hood/class_method/#deocrate-class-methods-with-magicgui","title":"Deocrate class methods with magicgui","text":"<p>Demonstrates decorating a class method with magicgui.</p> <p>Once the class is instantiated, <code>instance.method_name</code> will return a FunctionGui in which the instance will always be provided as the first argument (i.e. \"self\") when the FunctionGui or method is called.</p> <p></p> <p>Out:</p> <pre><code>instance: a, counter: 0.0, sigma: 0.0\ninstance: b, counter: 0.0, sigma: 0.0\n</code></pre> <p></p> <pre><code>from magicgui import event_loop, magicgui\nfrom magicgui.widgets import Container\n\n\nclass MyObject:\n    \"\"\"Example object class.\"\"\"\n\n    def __init__(self, name):\n        self.name = name\n        self.counter = 0.0\n\n    @magicgui(auto_call=True)\n    def method(self, sigma: float = 0):\n        \"\"\"Example class method.\"\"\"\n        print(f\"instance: {self.name}, counter: {self.counter}, sigma: {sigma}\")\n        self.counter = self.counter + sigma\n        return self.name\n\n\nwith event_loop():\n    a = MyObject(\"a\")\n    b = MyObject(\"b\")\n    container = Container(widgets=[a.method, b.method])\n    container.show()\n    assert a.method() == \"a\"\n    assert b.method() == \"b\"\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.038 seconds)</p> <p> Download Python source code: class_method.py</p> <p> Download Jupyter notebook: class_method.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"},{"location":"generated_examples/under_the_hood/mg_execution_times/","title":"Computation times","text":"<p>00:00.091 total execution time for generated_examples_under_the_hood files:</p> <p>+----------------------------------------------------------------------------------------+-----------+--------+ | self_reference (docs/examples/under_the_hood/self_reference.py) | 00:00.054 | 0.0 MB | +----------------------------------------------------------------------------------------+-----------+--------+ | class_method (docs/examples/under_the_hood/class_method.py)       | 00:00.038 | 0.0 MB | +----------------------------------------------------------------------------------------+-----------+--------+</p>"},{"location":"generated_examples/under_the_hood/self_reference/","title":"Self reference magicgui widgets","text":"<p>Note</p> <p>Click here to download the full example code</p>"},{"location":"generated_examples/under_the_hood/self_reference/#self-reference-magicgui-widgets","title":"Self reference magicgui widgets","text":"<p>Widgets created with magicgui can reference themselves, and use the widget API.</p> <p></p> <p>Out:</p> <pre><code>&lt;FunctionGui function(width=400, x: int = 50)&gt;\n</code></pre> <p></p> <pre><code>from magicgui import magicgui\n\n\n@magicgui(auto_call=True, width={\"max\": 800, \"min\": 100}, x={\"widget_type\": \"Slider\"})\ndef function(width=400, x: int = 50):\n    \"\"\"Example function.\"\"\"\n    # the widget can reference itself, and use the widget API\n    function.x.width = width\n\n\nfunction.show(run=True)\n</code></pre> <p>Total running time of the script: ( 0 minutes  0.054 seconds)</p> <p> Download Python source code: self_reference.py</p> <p> Download Jupyter notebook: self_reference.ipynb</p> <p>Gallery generated by mkdocs-gallery</p>"}]}